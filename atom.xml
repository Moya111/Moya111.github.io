<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农笔记</title>
  <icon>https://www.gravatar.com/avatar/b840c0dcf997bb27b1d7b9019219ef8d</icon>
  <subtitle>性格古怪，不善言辞</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//sunxingboo.github.io/"/>
  <updated>2021-08-04T07:08:54.198Z</updated>
  <id>//sunxingboo.github.io/</id>
  
  <author>
    <name>孙十一</name>
    <email>sunxingboz@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多重背包</title>
    <link href="2021/08/04/multi-pack/"/>
    <id>2021/08/04/multi-pack/</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-08-04T07:08:54.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg" width="400" height="300"/></p><a id="more"></a><h2 id="多重背包问题性质"><a href="#多重背包问题性质" class="headerlink" title="多重背包问题性质"></a>多重背包问题性质</h2><p>一个背包，它最大能收纳的重量为 $packWeight$。</p><p>一组物品，每种物品有一个或多个，第 $i$ 种物品的重量为 $weights[i]$，价值为 $values[i]$，数量为 $nums[i]$。</p><p>求背包能容纳的物品最大价值。这就是<strong>多重背包</strong>问题，很显然其与 <a href="https://sunxingboo.github.io/2021/07/12/01pack/" target="_blank" rel="noopener">$01$ 背包</a> 和 <a href="https://sunxingboo.github.io/2021/07/19/complete-pack/" target="_blank" rel="noopener">完全背包</a> 的差别是：</p><ul><li><a href="https://sunxingboo.github.io/2021/07/12/01pack/" target="_blank" rel="noopener">$01$ 背包</a> 的物品列表中，每种物品仅有 $1$​​ 件。</li><li><a href="https://sunxingboo.github.io/2021/07/19/complete-pack/" target="_blank" rel="noopener">完全背包</a> 的物品列表中，每种物品有无数件。</li><li>组合背包的物品列表中，每种物品有对应的指定数量的件数。</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在 <a href="https://sunxingboo.github.io/2021/07/12/01pack/" target="_blank" rel="noopener">$01$​ 背包</a> 问题中，物品只能选择一次，在实现中使用<strong>逆序</strong>遍历背包来防止物品被重复选取。</p><p>在 <a href="https://sunxingboo.github.io/2021/07/19/complete-pack/" target="_blank" rel="noopener">完全背包</a> 问题中，物品可以选择无数次，在实现中通过<strong>正序</strong>遍历背包来处理。</p><p>而在<strong>多重背包</strong>中，物品有指定的数量，以上两种处理方式都无法满足了。直观的想法是需要在处理的过程中控制选择物品的次数。</p><p>另一种方案就是将多重背包转化为 $01$​ 背包，只要把物品列表里的物品按照其数量展开就可以了。</p><p>例如：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|}    \hline packWeight&4\\    \hline weights&1&3&4\\    \hline values&15&20&30\\    \hline nums&3&2&1\\    \hline\end{array}</script><p>将物品展开</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|}    \hline packWeight&4\\    \hline weights&1&1&1&3&3&4\\    \hline values&15&15&15&20&20&30\\    \hline nums&1&1&1&1&1&1\\    \hline\end{array}</script><p>接下来问题就转化为了 <a href="https://sunxingboo.github.io/2021/07/12/01pack/" target="_blank" rel="noopener">$01$​ 背包</a> 问题。</p><h2 id="golang-代码实现"><a href="#golang-代码实现" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiPack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//展开物品，将多重背包转化为01背包</span></span><br><span class="line">    <span class="keyword">var</span> newWeights, newValues []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            newWeights = <span class="built_in">append</span>(newWeights, weights[i])</span><br><span class="line">            newValues = <span class="built_in">append</span>(newValues, values[i])</span><br><span class="line">            nums[i]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//可以对newWeights，newValues做一下异常判断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历展开后的物品列表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(newWeights); i++ &#123;</span><br><span class="line">        <span class="comment">//逆序遍历背包防止重复选择</span></span><br><span class="line">        <span class="keyword">for</span> j := packWeight; j &gt;= newWeights[i]; j-- &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - newWeights[i]] + newValues[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="//sunxingboo.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>几道完全背包问题</title>
    <link href="2021/07/29/complete-pack-application/"/>
    <id>2021/07/29/complete-pack-application/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-08-04T07:11:29.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg" width="400" height="300"/></p><a id="more"></a><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">leetcode 518</a></p><p>示例</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>本笔记不再考虑二维 $dp$ 数组情况，直接使用一维 $dp$ 数组，下面几道题目也一样。</p><p>本题中要凑的<strong>总金额</strong>就是背包的最大重量，并且必须要把背包填满。</p><p>要求的是能填满背包的方法数（硬币的选择方式组合数）。</p><p><strong>$dp$​ 数组定义</strong></p><p>$dp[j]$​ 代表为填满容量为 $j$​ 背包有 $dp[j]$​ 种方式。</p><p><strong>递推公式</strong></p><p>那么对于背包容量 $j$，在 $0$ ~ $i$ 选取物品 $coins[i]$，如果此时背包恰好还剩余 $j - coins[i]$ 的容量，那么再选一个 $coins[i]$ 就将背包填满了。此时填满 $j$ 容量的方法数和填满 $j - coins[i]$ 的方法数是一样的（因为从 $j - coins[i]$ 再选一个 $coins[i]$​​ 就填满了，只有这一种情况）。</p><p>而 $dp[j]$ 的最终结果，就是对于每一个物品的选择情况求和。</p><script type="math/tex; mode=display">dp[j] += dp[j - coins[i]]</script><p><strong>初始化方式</strong></p><p>在纯完全背包中，初始化 $dp[0] = 0$（容量为 $0$ 的背包能容纳的物品也是 $0$）。</p><p>但是在当前题目中是不可以的，因为每个 $dp[j]$ 都是通过前面遍历过的位置推导而来的，那么如果第一个位置 $dp[0] = 0$，那么所以 $dp[j]$ 都将是 $0$。</p><p>所以在本题题目中应该将 $dp[j]$ 设置为 $1$（填满容量为 $0$ 的背包的方法数为 $1$ 种，就是不选择物品）。</p><script type="math/tex; mode=display">dp[0] = 1</script><p><strong>遍历顺序</strong></p><p>与 $01$​ 背包不同，在完全背包中，遍历方式是有讲究的。</p><p>第一种方式：先遍历物品，再遍历背包。在这种方式中，每个物品的出现是有先后顺序的（也就是说答案是组合数）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历物品</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">    <span class="comment">//遍历背包最大容量，dp[0] 已经初始化，从 dp[1] 开始</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">        <span class="comment">//只有背包容量大于或等于当前硬币重量时，能能选择</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= coins[i] &#123;</span><br><span class="line">            <span class="comment">//累加所有情况</span></span><br><span class="line">            dp[j] += dp[j - coins[i]]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：先遍历背包，再遍历物品。在这种方式中，对于每个背包，每一个物品都可以先出现（也就是说答案是排列数）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历背包最大容量，dp[0] 已经初始化，从 dp[1] 开始</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">    <span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="comment">//只有背包容量大于或等于当前硬币重量时，能能选择</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= coins[i] &#123;</span><br><span class="line">            <span class="comment">//累加所有情况</span></span><br><span class="line">            dp[j] += dp[j - coins[i]]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例推导</strong></p><p>以实例 $coins = [1, 2, 5]$​ 为例展示推导过程：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}  \hline 0&0&0&0&0&0\\  \hline\end{array}</script><p>（1）初始化后：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}  \hline 1&0&0&0&0&0\\  \hline\end{array}</script><p>（2）对于 $coins[0]$​​​​​ 遍历背包容量：</p><script type="math/tex; mode=display">\begin{align}    dp[1] &= dp[1] + dp[1 - coins[0]]\\          &= dp[1] + dp[1 - 1]\\          &= dp[1] + dp[0]\\          &= 1\\          &其他索引位置同理\end{align}</script><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}  \hline 1&1&1&1&1&1\\  \hline\end{array}</script><ul><li>对于容量 $1$​ 的背包，选 $1$ 个 $1$​</li><li>对于容量 $2$​ 的背包，选 $2$​ 个 $1$​​</li><li>…</li></ul><p>所以每一个都是一种方法。</p><p>（3）对于 $coins[1]$​​​​ 遍历背包容量：$dp[1]$ 不满足 $j &gt;= coins[i]$​​​，跳过。</p><script type="math/tex; mode=display">\begin{align}    dp[2] &= dp[2] + dp[2 - coins[1]]\\          &= dp[2] + dp[2 - 2]\\          &= dp[2] + dp[0]\\          &= 1 + 1\\          &= 2\\          &其他索引位置同理\end{align}</script><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}  \hline 1&1&2&2&3&3\\  \hline\end{array}</script><ul><li>对于容量 $2$ 的背包<ul><li>$1 + 1$</li><li>$2$​</li></ul></li><li>对于容量 $3$​​ 的背包<ul><li>$1 + 1 + 1$​</li><li>$1 + 2$​</li></ul></li><li><p>对于容量 $4$​​​ 的背包</p><ul><li>$1 + 1 + 1 + 1$​​</li><li>$1 + 1 + 2$​​</li><li>$2 + 2$</li></ul></li><li><p>对于容量 $5$​​ 的背包</p><ul><li>$1 + 1 + 1 + 1 + 1$​</li><li>$1 + 1 + 1 + 2 $​</li><li>$1 + 2 + 2$​</li></ul></li></ul><p>（4）对于 $coins[2]$​ 遍历操作同理，略。</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}  \hline 1&1&2&2&3&4\\  \hline\end{array}</script><h3 id="golang-代码实现"><a href="#golang-代码实现" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  coins = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount + <span class="number">1</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j &gt;= coins[i] &#123;</span><br><span class="line">        dp[j] += dp[j - coins[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(mn)$​，其中 $m$​ 是需要凑满的目标数 $amount$​，$n$​ 是硬币个数。</p><p>空间复杂度是 $O(m)$。</p><h2 id="组合总和-IV"><a href="#组合总和-IV" class="headerlink" title="组合总和 IV"></a>组合总和 IV</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">leetcode 377</a></p><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。 </p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>$dp$ 数组定义</strong></p><p>$dp[j]$​​ 代表填满容量 $j$ 的背包的元素组合数。</p><p><strong>递推公式</strong></p><p>对于容量 $j$ 的背包、在选择物品 $nums[i]$​​ 时，装满背包的组合数，就是装满容量 $j - nums[i]$​​​ 的背包的组合数。</p><p>那么对于所以物品 $nums$​，装满容量 $j$ 的背包的组合总数，就是把上述针对每个物品的组合数求总和。</p><script type="math/tex; mode=display">dp[j] = dp[j] + dp[j - nums[i]]</script><p><strong>$dp$ 数组初始化</strong></p><p>从递推公式中可以看出，结果是累加求得的，那么 $dp$​ 数组的第一个位置就必须要初始化。</p><p>要装满容量为 $0$ 的背包，只能是什么都选择，也就是空集合，只有这一种方式。 </p><script type="math/tex; mode=display">dp[0] = 1</script><p><strong>遍历顺序</strong></p><p>因为是本题求的是所以可能的组合数，也就是求排列。</p><p>在上一道题目中已经分析，遍历顺序就是先遍历背包（保证选择物品是无序的），再遍历物品。</p><p><strong>举例推导</strong></p><p>以示例为例，推导一下过程</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 0&0&0&0&0\\  \hline\end{array}</script><p>初始化</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&0&0&0&0\\  \hline\end{array}</script><p>物品 $1$​​，遍历所以物品</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&1&0&0&0\\  \hline\end{array}</script><p>背包 $2$​​​，遍历所有物品</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&1&2&0&0\\  \hline\end{array}</script><p>背包 $3$​​，遍历所有物品</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&1&2&4&0\\  \hline\end{array}</script><p>背包 $4$​​，遍历所有物品</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&1&2&4&7\\  \hline\end{array}</script><h3 id="golang-代码实现-1"><a href="#golang-代码实现-1" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, target + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//填满0容量的背包，有一种组合，就是空[]</span></span><br><span class="line">    <span class="comment">//本题求组合，所以遍历顺序必须先背包后物品</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= target; j++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt;= nums[i] &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(mn)$，其中 $m$ 是需要凑满的目标数 $target$，$n$ 是硬币个数。</p><p>空间复杂度是 $O(m)$。</p><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode 70</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>爬到第 $0$​ 阶台阶有 $1$ 种方法，就是不爬。</p><p>爬到第 $1$​ 阶台阶，只能选择走 $1$ 阶，有 $1$​ 种方法。</p><p>爬到第 $2$​ 阶台阶，可以选择每次走 $1$​ 阶，也可以选择一次走 $2$ 阶，有 $2$​​ 种方法。</p><p>爬到第 $3$​​ 阶台阶，可以选择从第 $2$​ 阶走 $1$​ 阶到达，也可以选择从第 $1$​ 阶一次走 $2$​ 阶到达，有 $f(3 - 1) + f(3 - 2)$ 种方法。</p><p>这是一道很简单的题目，实际就是求一下斐波那契数列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">2</span>) + climbStairs(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>递归解法会有大量的重复计算，例如计算 $f(3 - 2)$​ 的内部已经递归计算了 $f(3 - 1)$​。</p><p>可以通过一个数组存储前一个计算的值，正向推导。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际最终答案需要的只是 $dp$ 数组最后一个元素，实际使用长度为 $2$​ 的 $dp$ 数组就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        tmp := dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>将问题改为每一次可以爬 $1$​ 、 $2$​ 、 $3$​​​ 、… 阶台阶，爬到第 $n$​ 阶台阶有多少种方法？</p><p><strong>分析</strong></p><p>实际上可以理解为，现在有一组物品：$[1, 2, 3, …, n]$，有一个背包最大容量为 $n$​​，要装满这个背包有多少种选择方式。</p><p>物品可以无限次重复选择，所以这就是一道完全背包的问题。</p><p>与上面的题就是一样的解法了，重点同样在于求的是排列，所以要先遍历背包。</p><h2 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">leetcode 322</a></p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p> 示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>$dp$ 数组定义</strong></p><p>$dp[j]$ 代表装满容量为 $j$ 的背包所使用的最少的硬币数量。</p><p><strong>递推公式</strong></p><p>那么对于容量 $j$​ 的背包，在选择硬币 $coins[i]$​ 后刚好装满，那么此时使用的硬币数量就是 $dp[j - coins[i]] + 1$​。</p><p>那么对于所有的硬币 $coins$​ ，$dp[j]$ 就要取一个最小的值。</p><script type="math/tex; mode=display">dp[j] = min(dp[j], dp[j - coins[i]])</script><p><strong>初始化</strong></p><p>这里的初始化非常关键，前几道题目的在初始化时只需要考虑第一个元素就可以了。但是本题，递推公式需要计算最小值，那么如果还是初始化为 $0$，那么在状态转移过程中就会都取了 $0$ 值，达不到推导的目的。</p><p>所以 $dp[0] = 0$，装满容量为 $0$ 的背包，需要最少 $0$ 枚硬币。</p><p>其他位置都初始化为 $MaxInt$​。</p><p><strong>遍历顺序</strong></p><p>本题求的是最小硬币个数，所以不关心排列还是组合，遍历顺序是无所谓的。</p><h3 id="golang-代码实现-2"><a href="#golang-代码实现-2" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">//背包</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">    dp[j] = math.MaxInt32</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先遍历物品，再遍历背包（本题不是求排列组合，所以顺序是可以颠倒的）</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j &gt;= coins[i] &#123;</span><br><span class="line">        dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fmt.Println(dp)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">if</span> dp[amount] &gt;= math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(mn)$，其中 $m$ 是需要凑满的金额总数，$n$ 是硬币个数。</p><p>空间复杂度是 $O(m)$。</p><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">leetcode 279</a></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><p>整体跟前几道题目大同小异，不再详细记录了。</p><p>只要理解了题目意思就简单了，物品就是完全平方数列表，那么有哪些完全平方数呢</p><script type="math/tex; mode=display">[1, 4, 9, 16, 25,...]</script><p>之前的题目里，物品列表是题目给定的，而本题题目列表是根据参数动态变化的，需要自己计算。</p><p>对于背包容量 $n$​，最小的有意义的完全平方数就是 $n$​​，所有大于这个数值的完全平方数都无法使用，因为超过了背包的最大容量。</p><p>所以物品列表实际就是 $1^2$​​ ~ $(\sqrt{n})^2$​​​​，只需要在遍历物品时从 $1$ 开始，到 $\sqrt{n}$ 截止，然后自行计算当前遍历到的完全平方数即可。</p><p><strong>$dp$ 数组定义</strong></p><p>$dp[j]$ 代表装满容量为 $j$​ 的背包所使用的最少的完全平方数的数量。</p><p><strong>初始化</strong></p><p>跟上一道题类似。$dp[0] = 0$，其他为 $MaxInt$​。</p><p><strong>遍历顺序</strong></p><p>与上一题一样，同样不关心组合还是排列，所以遍历顺序随意。</p><h3 id="golang-代码实现-3"><a href="#golang-代码实现-3" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    dp[i] = math.MaxInt32</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//物品就是从1开始的每个数的平方，并控制物品列表最大到 i*i</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i*i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="comment">//遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j &gt;= (i * i) &#123; <span class="comment">//物品的价值就是 i*i，之前的物品价值都是固定的，本题需要自己计算</span></span><br><span class="line">        dp[j] = min(dp[j], dp[j - (i * i)] + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>外层循环最大要遍历 $n$，内层循环最大遍历 $\sqrt{n}$​，所以时间复杂度为 $O(n\sqrt{n})$。</p><p>空间复杂度为 $O(n)$。</p><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">leetcode 139</a></p><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"leetcode"</span>, <span class="attr">wordDict</span> = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br></pre></td></tr></table></figure><h3 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h3><p>这道题目与前几道题目的差别就有些大了，但实际上也是一道完全背包问题。</p><p>物品列表就是 $wordDict$​，背包就是字符串 $s$​，把 $s$​ 拆分为一个或多个 $wordDict$​​ 中的单词反，这一操作反过来理解就是从物品列表中任意选择单词，最终能够拼成字符串 $s$​（也就是把背包装满），单词可以重复选择，这就是一个完全背包问题。</p><p>之前的题目物品列表都是固定的，操作过程是：选择物品，放入背包。</p><p>而本题中，这个操作程就多了一个前置动作：先截取子字符串，然后判断是否存在这个物品，存在的话才能放入背包（当然也可以预先生成一个包含所有的子串的容器，然后逐个判断）。</p><p><strong>$dp$ 数组定义</strong></p><p>背包就是字符串 $s$，边界条件就是空字符串，所以背包就是字符串 $s$ 的长度 $+1$​。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于 $dp[j]$ ，指字符串长度为 $j$ 。如果 $dp[j]$ 为 $true$，表示 $s[0:j+1]$ 可以拆分为一个或多个在 $wordDict$ 中出现的单词。</p><p><strong>递推公式</strong></p><p>对于每个 $dp[j]$​，从 $i \in [0, j - 1]$​ 遍历字符串 $s$​，当 $dp[i]=true$​，并且 $s[i:j]$​ 在 $wordDict$​ 中时，$dp[j] = true$​​。</p><p>之前的题目中，在选择物品时，对于物品 $nums[i]$，只需要考虑选或不选，并通过 $dp[j - nums[i]]$ 就可以定位到上一个物品的选择情况。</p><p>但是在本题中，对于背包容量 $j$ 和物品遍历 $i$​，$i$ 并不是一个唯一的物品，而是从 $0$ 到 $i$ 可能出现的所有子串。</p><p>例如在求 $dp[3]$​​​ 时，如果：</p><ul><li>$dp[2] = true$​，且 $wordDict$​​ 中包含 $s[2:3]$​</li><li>$dp[1] = true$​​，且 $wordDict$​​ 中包含 $s[1:3]$​​​</li><li>$wordDict$ 中包含 $s[0:3]$</li></ul><p>三种情况满足一种，就说明 $s[0:j]$ 这个子串是可以被拆分为一个或多个 $wordDict$​ 中的单词的。</p><p><strong>初始化</strong></p><p>因为 $dp[j]$ 的推导依赖前面的推导结果，所以 $dp[0]$ 必须初始化为 $true$，其他位置为 $false$​。</p><p><strong>遍历顺序</strong></p><p>本题不用考虑排列还是组合，所以遍历顺序就是无所谓的。</p><p>但是需要注意的是，如果先遍历物品的话，那么此时是没有参数遍历帮助我们截取子串的，那么就需要像如上分析一样，预先生成一个包含所有子串的容器当作物品列表，然后在后续的遍历过程中再判断子串是否在 $wordDict$ 中。</p><p>所以本题先遍历背包容量比较容易一些。</p><p><strong>举例推导</strong></p><p>以示例为例，定义背包</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|}  \hline  0&1&2&3&4&5&6&7&8\\  \hline  &l&e&e&t&c&o&d&e\\  \hline false&false&false&false&false&false&false&false&false\\  \hline\end{array}</script><p>初始化</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|}  \hline  0&1&2&3&4&5&6&7&8\\  \hline  &l&e&e&t&c&o&d&e\\  \hline true&false&false&false&false&false&false&false&false\\  \hline\end{array}</script><p>容量 $1$​，能截取的子串是 <code>l</code>，$wordDict$​ 中不存在。</p><p>容量 $2$​​，能截取出的子串依次是 <code>le</code>、<code>e</code>，$wordDict$​​​​ 中都不存在。</p><p>容量 $3$，能截取出的子串依次是 <code>lee</code>、<code>ee</code>、<code>e</code>，$wordDict$ 中都不存在。</p><p>容量 $4$，能截取出的子串依次是 <code>leet</code>、<code>eet</code>、<code>et</code>、<code>t</code>，$wordDict$​ 中存在 <code>leet</code>，更新 $dp$ 数组：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|}  \hline  0&1&2&3&4&5&6&7&8\\  \hline  &l&e&e&t&c&o&d&e\\  \hline true&false&false&false&true&false&false&false&false\\  \hline\end{array}</script><p>容量 $5$，能截取出的子串依次是 <code>leetc</code>、<code>eetc</code>、<code>etc</code>、<code>tc</code>、<code>c</code>，$wordDict$ 中都不存在。</p><p>容量 $6$​，能截取出的子串依次是 <code>leetco</code>、<code>eetco</code>、<code>etco</code>、<code>tco</code>、<code>co</code>，$wordDict$​ 中都不存在。</p><p>容量 $7$​，能截取出的子串依次是 <code>leetcod</code>、<code>eetcod</code>、<code>etcod</code>、<code>tcod</code>、<code>cod</code>，$wordDict$​​​ 中都不存在。</p><p>容量 $8$​，能截取出的子串依次是 <code>leetcode</code>、<code>eetcode</code>、<code>etcode</code>、<code>tcode</code>、<code>code</code>，$wordDict$​​ 中存在 <code>code</code>，更新 $dp$ 数组：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|}  \hline  0&1&2&3&4&5&6&7&8\\  \hline  &l&e&e&t&c&o&d&e\\  \hline true&false&false&false&true&false&false&false&true\\  \hline\end{array}</script><h3 id="golang-代码实现-4"><a href="#golang-代码实现-4" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        m[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//背包</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//先遍历背包</span></span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">        <span class="comment">//截取子字符串，尝试去搜索是否存在对应的物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; j; i++ &#123;</span><br><span class="line">            <span class="comment">//背包容量 j 对应的就是 s 的第几个字符</span></span><br><span class="line">      <span class="keyword">if</span> dp[i] &amp;&amp; m[s[i:j]] &#123;</span><br><span class="line">        dp[j] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(dp)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>首先需要遍历字符串长度 $n$，然后对于每个节点又最多有 $n$ 个子串切割，所以时间复杂度为 $O(n)$。</p><p>空间复杂度为 $O(n$)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="//sunxingboo.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>数据区域元素和（“前缀和”方法）</title>
    <link href="2021/07/24/range-sum-query/"/>
    <id>2021/07/24/range-sum-query/</id>
    <published>2021-07-23T16:00:00.000Z</published>
    <updated>2021-08-04T02:28:55.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j（i ≤ j）</code>范围内元素的总和，包含 <code>i</code>、<code>j</code> 两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j（i ≤ j）</code>范围内元素的总和，包含 <code>i</code>、<code>j</code> 两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"NumArray"</span>, <span class="string">"sumRange"</span>, <span class="string">"sumRange"</span>, <span class="string">"sumRange"</span>]</span><br><span class="line">[[[<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">5</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]);</span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// return 1 ((-2) + 0 + 3)</span></span><br><span class="line">numArray.sumRange(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// return -1 (3 + (-5) + 2 + (-1)) </span></span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span></span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h2 id="golang代码实现"><a href="#golang代码实现" class="headerlink" title="golang代码实现"></a>golang代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    preSum []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化时间复杂度 O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line">    <span class="comment">//nums        1, 2, 3, 4</span></span><br><span class="line">    <span class="comment">//preSum   0, 1, 3, 6, 10  </span></span><br><span class="line">    preSum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        preSum[i + <span class="number">1</span>] = v + preSum[i]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(preSum)</span><br><span class="line">    <span class="keyword">return</span> NumArray&#123;preSum: preSum&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索时间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.preSum[right + <span class="number">1</span>] - this.preSum[left]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.SumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt;，求出数组从索引 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j（i
      
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="前缀和" scheme="//sunxingboo.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>完全背包</title>
    <link href="2021/07/19/complete-pack/"/>
    <id>2021/07/19/complete-pack/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-08-04T07:11:00.691Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg" width="400" height="300"/></p><a id="more"></a><h2 id="理解完全背包的性质"><a href="#理解完全背包的性质" class="headerlink" title="理解完全背包的性质"></a>理解完全背包的性质</h2><p>在<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题中，每一个物品的数量只有一个（也就是说每个物品只能选择一次）。</p><p>而当每个物品的数量有 $N$ 个（也就是对于同一重量、同一价值的物品可以多次选择）时，这就是一个<strong>完全背包</strong>的问题。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>把<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题稍作修改就成为了<strong>完全背包</strong>问题。</p><p>一个背包，它最大能收纳的重量为 $bagWeight$。</p><p>一组物品，每个物品有无数个（可以重复选择），第 $i$ 个物品的重量为 $weights[i]$，它的价值为 $values[i]$。</p><p>求背包能容纳的物品的最大价值。</p><script type="math/tex; mode=display">示例\ \ \\begin{array}{|c|c|c|c|}    \hline bagWeight&4\\    \hline weights&1&3&4\\    \hline values&15&20&30\\    \hline\end{array}</script><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题中，为了防止物品被重复选择，内层循环采用了逆序遍历。</p><p>但是在完全背包问题中，可以重复选用物品，所以将内层循环改为正序遍历就可以了。</p><h2 id="二维-dp-数组"><a href="#二维-dp-数组" class="headerlink" title="二维 $dp$ 数组"></a>二维 $dp$ 数组</h2><p>这里 $dp$ 数组下标定义与<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 是相同的。</p><p>$dp[i][j]$ 表示从下标为 $0$ ~ $i$ 的物品中任意选，背包最大容量为 $j$ 时，背包能容纳的最大重量。</p><p>完全背包中 $dp[i][j]$ 同样可以从两种情况得到：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}    dp[i - 1][j]\\    dp[i][j - weights[i]] + values[i]\end{cases}</script><p>第一种情况，假设此时背包剩余容量已无法容纳物品 $i$。背包最大容量为 $j$， 从下标为 $0$ ~ $i$ 的物品中任意选择物品得到的物品最大价值，与背包最大容量为 $j$， 从下标为 $0$ ~ $i - 1$ 的物品中任意选择物品得到的物品最大价值是相同的。</p><p>第二种情况，假设背包剩余容量可以容纳物品 $i$。显然把它放进背包需要消耗 $weights[i]$ 的容量，也就是扣除一个物品 $i$ 的重量后，背包剩余容量为 $j - weights[i]$，则从下标为 $0$ ~ $i$ 的物品中任意选择物品，最大容量为 $j - weights[i]$ 的背包能容纳的物品最大价值就是 $dp[i][j - weights[i]]$，然后再加上一个刚刚被暂时扣除的物品 $i$ 的价值。</p><p>直接列举一下 $dp$ 数组的推导过程：</p><p>初始状态</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0\\    \hline 物品1\\    \hline 物品2\\    \hline\end{array}</script><p>初始化 $dp$ 数组后，背包最大重量为 $0$ 时，能容纳的物品最大价值必然是 $0$。</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0&0\\    \hline 物品1&0\\    \hline 物品2&0\\    \hline\end{array}</script><p>遍历物品 $0$ （物品可以重复选择了，遍历完物品 $0$ 后，第一行数据与 $01$ 背包明显不同）</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0&0&15&30&45&60\\    \hline 物品1&0\\    \hline 物品2&0\\    \hline\end{array}</script><p>遍历物品 $1$</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0&0&15&30&45&60\\    \hline 物品1&0&0&0&45&60\\    \hline 物品2&0\\    \hline\end{array}</script><p>遍历物品 $2$</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0&0&15&30&45&60\\    \hline 物品1&0&0&0&45&60\\    \hline 物品2&0&0&0&0&60\\    \hline\end{array}</script><p><strong>golang 代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  weights = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">  values = []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">completePack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weights))</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"初始化前: "</span>, dp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weights[<span class="number">0</span>]] + values[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"初始化后: "</span>, dp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="comment">//遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weights[i] &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weights[i]] + values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(dp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(weights) - <span class="number">1</span>][packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dp$ 数组的遍历顺序与<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 也是相同的。先遍历物品或先遍历背包都是可以的。</p><h2 id="一维-dp-数组"><a href="#一维-dp-数组" class="headerlink" title="一维 $dp$ 数组"></a>一维 $dp$ 数组</h2><p>同样与<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题中的一维 $dp$ 数组相似，不再详细分析，先记录一下代码实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">completePack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">"初始化前: "</span>, dp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="comment">//遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weights[i] &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(dp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题中，一维 $dp$ 数组的遍历过程必须在外层循环遍历物品，内层循环遍历背包容量，而在<strong>完全背包（指纯完全背包，本题就是一个纯完全背包问题）</strong>中，先遍历物品和先遍历背包容量是一样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纯<strong>完全背包</strong>问题与纯<a href="https://sunxingboo.github.io/2021/07/12/01bag/" target="_blank" rel="noopener"> $01$ 背包</a> 问题的差别：</p><ul><li>在分析问题时，可以理解为物品是不是可以重复选择（每个物品有多件）</li><li>在代码实现中，可以理解为对背包容量的遍历方向（完全背包是正序（从小到大）遍历背包容量，而 $01$ 背包是逆序（从大到小）遍历背包容量）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="//sunxingboo.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>一道很有代表性的数组动态规划问题</title>
    <link href="2021/07/18/sub-array-sum/"/>
    <id>2021/07/18/sub-array-sum/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-07-20T10:58:28.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">leetcode 剑指 offer 42</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p><em>要求时间复杂度为 $O(n)$。</em></p><p>示例1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>暴力解法</strong></p><p>首先考虑暴力解法。也就是先求所有可能的连续子数组，然后找到最大的子数组和。</p><p>假设 $nums$ 有 $n$ 个元素，以第 $1$ 个元素开头的子集有 $n - 1$ 种，以第 $2$ 个元素开头的子集有 $n - 2$ 种，以此类推，以第 $n$ 个元素开头的子集有 $1$ 种。</p><p>所有连续子集的总数就是：</p><script type="math/tex; mode=display">\sum_{i=1}^{n - 1}{i}</script><p>算法时间复杂度为 $O(n^2)$。</p><p><strong>动态规划</strong></p><p>在暴力解法中，先选定的是子集合开头的元素，此时还没有遍历到集合末尾，根本无法知道有多少种子集合，也就无法获取子集合中的最大和。</p><p>其实可以反过来想，假设选定的是一个子集合的末尾元素，那么此时以当前元素为结尾的子集合有多少种可能就已经确定了，显然就可以获取到最大的子集和。</p><p>举几个例子</p><p>例如当前遍历到 $nums[1]$，以它为末尾的子集有 $2$ 个：</p><script type="math/tex; mode=display">\begin{align*}\begin{array}{|c|c|}  \hline -2&1\\  \hline\end{array} \\\begin{array}{|c|}  \hline 1\\  \hline\end{array} \end{align*}</script><p>例如当前遍历到 $nums[2]$，以它为末尾的子集有 $3$ 个：</p><script type="math/tex; mode=display">\begin{align*}\begin{array}{|c|c|c|}  \hline -2&1&-3\\  \hline\end{array} \\\begin{array}{|c|c|}  \hline 1&-3\\  \hline\end{array}\\\begin{array}{|c|}  \hline -3\\  \hline\end{array}\end{align*}</script><p>例如当前遍历到 $nums[3]$，以它为末尾的子集有 $4$ 个：</p><script type="math/tex; mode=display">\begin{align*}\begin{array}{|c|c|c|c|}  \hline -2&1&-3&4\\  \hline\end{array} \\\begin{array}{|c|c|c|}  \hline 1&-3&4\\  \hline\end{array}\\\begin{array}{|c|c|}  \hline -3&4\\  \hline\end{array}\\\begin{array}{|c|}  \hline 4\\  \hline\end{array}\end{align*}</script><p>可以看出当遍历到当前位置时，把所有的以前一个元素为结尾的子集再补上一个当前元素；另外再加一个既以当前元素开始，也以当前元素结尾的子集，就得到了以当前元素为结尾的所有可能的子集。</p><p>所以，遍历到每个位置时，以次位置元素为结尾的所有可能的子集中最大的和就已经能确认，这样只要遍历一遍 $nums$ 集合，就能够得到答案，时间复杂度为 $O(n)$。</p><p><strong>$dp$ 数组定义</strong></p><p>$dp[i]$ 代表以 $nums[i]$ 为结尾的所有可能的子集中，最大的子集和。</p><p>一般的题目都需要我们单独声明 $dp$ 数组，来存储计算结果，但本题中实际上在参数给入的集合 $nums$ 中直接操作就可以了，只需要额外再维护一个 $max$ 遍历来保存遍历过程中的最大值，也就是结果。</p><p>这样节省了空间消耗，空间复杂度 $O(1)$。</p><p><strong>初始化方式</strong></p><p>对于数组第一个元素，以它结尾的子集显然只有一种可能，就是它本身，所以子集的和的最大值也就是它本身。</p><p>也就是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>但是刚刚说过，我们可以使用 $nums$ 集合来作为 $dp$ 数组节省空间，所以实际上也就不需要任何初始化操作。</p><p>但是需要把维护的 $max$ 遍历初始化为 $nums[0]$。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max := nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="golang-代码实现"><a href="#golang-代码实现" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">//计算以当前元素为结尾的所有可能的子集中最大的子集和</span></span><br><span class="line">        <span class="comment">//以前一个元素为结尾的最大子集合已经算出，这里只要把当前元素和前一个最大子集和相加，并跟当前元素比较找到最大值即可</span></span><br><span class="line">        <span class="comment">//如果两者相加不大于当前元素，说明以当前元素为结尾的子集中，最大的子集和就是当前元素的值，所以不需要处理</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i - <span class="number">1</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] = nums[i] + nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验是否需要更新最大的子集和</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;连续子数组的最大和&quot;&gt;&lt;a href=&quot;#连续子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;连续子数组的最大和&quot;&gt;&lt;/a&gt;连续子数组的最大和&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 剑指 offer 42&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要求时间复杂度为 $O(n)$。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 连续子数组 [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] 的和最大，为 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>几道01背包的应用题</title>
    <link href="2021/07/15/01pack-application/"/>
    <id>2021/07/15/01pack-application/</id>
    <published>2021-07-14T16:00:00.000Z</published>
    <updated>2021-08-04T07:10:20.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg" width="400" height="300"/></p><a id="more"></a><p>学完 $01$ 背包之后，简单记录一下几道 $01$ 背包应用题的解题思路和代码实现（有的题目在不考虑超时的情况下，也可以通过回溯等其他解法求解，这里暂不考虑，只记录利用动态规划 $01$ 背包的解题思路）。</p><p>通用函数 $max$ 代码如下，后续不再记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">leetcode 416</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个只包含<em>正整数</em>的<em>非空</em>数组 $nums$ 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>] 。</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>本题的预期是将一个数组分为两个子数组，且这两个子数组的元素和相等。</p><p>假设数组元素和为 $sum$，那么显然只有在 $sum$ 为<strong>偶数</strong>时才可能成立，若 $sum$ 为奇数则数组必然不可拆分。</p><p>拆分后的子数组元素和为必须为 $\frac{sum}{2}$，否则是不成立的。</p><p>那么实际上现在就可以将这个问题转化为 $01$ 背包问题了。将 $\frac{sum}{2}$ 理解为<strong>背包</strong>的容量，物品以及物品的<strong>重量</strong>和<strong>价值</strong>都是 $nums$。</p><p>这样就把问题转化成了：一个容量为 $\frac{sum}{2}$ 的背包，任意从物品 $nums$ 中选择，最大能容纳的物品重量。当能容纳的最大重量等于 $\frac{sum}{2}$ （刚好装满）时，则说明数组 $nums$ 能拆分成两个元素和相等的子数组。</p><h3 id="golang代码实现"><a href="#golang代码实现" class="headerlink" title="golang代码实现"></a>golang代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//先判断数组和是否为偶数</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取数组和的一半作为背包容量</span></span><br><span class="line">  target := sum / <span class="number">2</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, target + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= nums[i] &#123;</span><br><span class="line">          dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当背包刚好装满时，数组可以拆分为元素和相等的两个子数组</span></span><br><span class="line">    <span class="keyword">return</span> dp[target] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(mn)$，$m$ 是数组元素总数，$n$ 是背包最大容量。</p><p>空间复杂度 $O(n)$。</p><h2 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h2><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">leetcode 1049</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一堆石头，用整数数组 $stones$ 表示。其中 $stones[i]$ 表示第 $i$ 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x \leq y$。那么粉碎的可能结果如下：</p><ul><li><p>如果 $x = y$，那么两块石头都会被完全粉碎；</p></li><li><p>如果 $x \neq y$，那么重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头新重量为 $y-x$。</p></li></ul><p>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 $0$。</p><p>示例</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">组合 <span class="number">2</span> 和 <span class="number">4</span>，得到 <span class="number">2</span>，所以数组转化为 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">7</span> 和 <span class="number">8</span>，得到 <span class="number">1</span>，所以数组转化为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">2</span> 和 <span class="number">1</span>，得到 <span class="number">1</span>，所以数组转化为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">组合 <span class="number">1</span> 和 <span class="number">1</span>，得到 <span class="number">0</span>，所以数组转化为 [<span class="number">1</span>]，这就是最优值。</span><br></pre></td></tr></table></figure><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>题目期望的是，在两两碰撞之后，最终剩下的石头最小。</p><p>那么实际可以理解为，将数组<strong>尽量的</strong>分为元素和相等的两个子数组，这样两个子数组中的石头两两相撞，重量大的在相撞抵消掉一部分重量之后放回原数组，再继续选择两个石头相撞，那么最终剩余的重量就是最小的。</p><p>如果拆分出的两个子数组元素和恰好相等，则最终剩余的石头重量就是 $0$。</p><p>这样实际上又把问题转化为了 $01$ 背包问题：</p><p>假设石头数组的重量和为 $sum$，现在有一个背包的最大容量为 $\frac{sum}{2}$，当背包装满时剩余的石头重量为 $sum - \frac{sum}{2}$。当 $sum$ 为奇数时，$\frac{sum}{2}$ 是向下取整的，所以整体来说 $sum - \frac{sum}{2} \geq \frac{sum}{2}$。</p><p>所以只考虑背包最多能容纳多少重量的石头就可以了，假设最多容纳石头重量为 $dp[\frac{sum}{2}]$，则剩余石头为 $sum - dp[\frac{sum}{2}]$，则碰撞抵消完成后最终剩余的就是两者的差值  $(sum - dp[\frac{sum}{2}]) - dp[\frac{sum}{2}]$ （因为 $(sum - dp[\frac{sum}{2}]) \geq dp[\frac{sum}{2}]$）。</p><p>与上一题相似，物品的重量和价值都可以理解为石头数组 $stones$。</p><h3 id="golang代码实现-1"><a href="#golang代码实现-1" class="headerlink" title="golang代码实现"></a>golang代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"> <span class="comment">//求和，这道题奇数和偶数都是可以的</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stones &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//求背包最大重量（将石头总和拆分，尽可能平均分配到两部分中，这样才能最大程度的消除）</span></span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, target + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//剩余部分重量减去背包容纳的最大重量就是抵消后剩余的最小值</span></span><br><span class="line">    <span class="keyword">return</span> (sum - dp[target]) - dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(mn)$，$m$ 是石头总数，$n$ 是背包最大容量。</p><p>空间复杂度 $O(n)$。</p><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">leetcode 494</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</p><p>返回可以通过上述方法构造的、运算结果等于 target 的不同表达式的数目。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一共有 <span class="number">5</span> 种方法让最终目标和为 <span class="number">3</span> 。</span><br><span class="line"><span class="number">-1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>思路</strong></p><p>前两道题目可以很容易的转换成 $01$ 背包问题求解，但这道题直观上看就不那么明显了。</p><p>题目的目的是，给一组数，可加可减，最终得到需要的目标值，求一共有多少种不同的组合方式。</p><p>假设元素总和为 $sum$，最终需要的目标值是 $target$，选取过程中用于执行加法的元素和为 $x$，用于减法的元素和为 $y$，那么则有：</p><script type="math/tex; mode=display">\begin{align*}&\begin{cases}x - y = target\\x + y = sum\\\end{cases}\\&\Rightarrow 2x = target + sum\\&\Rightarrow x = \frac{target + sum}{2}\end{align*}</script><p>也就是说，只要从大集合中，找到一组元素和为 $\frac{target + sum}{2}$ 的子集合，就找到了一种得到 $target$ 的方式。那么题目的答案就可以转化为求不同的和为 $\frac{target + sum}{2}$ 的子集数量。</p><p>也就是可以理解为，一个容量为 $\frac{target + sum}{2}$ 的背包，从 $nums$ 中任意选择物品，最多有多少种不同的方式能装满背包。物品的重量和价值都是 $nums[i]$。</p><p>这样就把这个问题转化成了 $01$ 背包问题。</p><p><strong>$dp$ 数组定义</strong></p><p>前面两道题目的 $dp$ 数组与 $01$ 背包基础定义的 $dp$ 数组基本相同，但目前这道题目显然 $dp$ 数组的含义就不相同了。</p><p>前面两题 $dp$ 数组下标定义 $dp[j]$ 代表的是容量为 $j$ 的背包，从物品 $0$ ~ $i$ 中任意选择能容纳的最大物品价值和。</p><p>而本题 $dp[j]$ 代表把容量为 $j$ 的背包装满有多少种不同的方式（与爬楼梯的问题很相似）。</p><p><strong>递推公式</strong></p><script type="math/tex; mode=display">dp[j] = dp[j] + dp[j - nums[i]]</script><p>装满最大容量为 $j - nums[i]$ 的背包共有 $dp[j - nums[i]]$ 种方法。那么要装满最大容量为 $dp[j]$ 的背包，只需要再选取 $nums[i]$ 就可以了，所以与装满 $dp[j - nums[i]]$ 的方法种类是相等的。 </p><p>那么对于每一个元素 $nums[i]$ 在 $dp[j]$ 位置，都能通过 $dp[j - nums[i]]$ 定位到选择 $nums[i]$ 来使背包能够装满的方法数量，索引对每一次遍历求和，就得到了填满容量为 $j$ 的背包的方法总数 $dp[j]$。</p><p><em>这里直接使用了一维 $dp$ 数组，不如使用二维 $dp$ 数组容易理解。</em></p><p><strong>$dp$ 数组初始化</strong></p><p>除了 $dp$ 数组的定义和递推公式与前两道题不同之外，另一个不同点就是 $dp$ 数组的初始化方式。</p><p>之前的初始化，在背包最大容量为 $0$ 时，将对应的 $dp$ 数组值设置为了 $0$，含义是<strong>容量为0的背包</strong>，能装入的物品最大价值为 $0$ （这是与 $dp$ 数组定义有关的）。</p><p>而在本题中 $dp$ 数组每一个下标值代表的是<strong>装满</strong>该下标值容量的背包的方法总数，那么对于 $dp[0]$ （也就是容量为 $0$ 的背包），装满它的方法总数就不应该是 $0$， 而应该是 $1$，因为<strong>一个物品都不选择</strong>也是一种选择方法。</p><p>所以本题的 $dp$ 数组初始化方式应该是：</p><script type="math/tex; mode=display">dp[0] = 1</script><p><strong>举例推导</strong></p><p>以题目示例为例，推演一下 $dp$ 数组变化过程帮助理解：</p><script type="math/tex; mode=display">\begin{align}bagWeight &= \frac{sum + target}{2}\\                    &= \frac{5 + 3}{2}\\                    &= 4\end{align}</script><p>所以背包初始化后为：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|}  \hline 1&0&0&0&0\\  \hline\end{array}\\填满容量为 \ 0 \ 的背包只有一种方法，就是什么都不选</script><p>只从第 $1$ 个物品中选择：</p><script type="math/tex; mode=display">nums[0] \qquad \begin{array}{|c|c|c|c|c|}  \hline 1&1&0&0&0\\  \hline\end{array}\\ 选择\ nums[0]\ 可以填满容量为\ 1 \ 的背包</script><p>从前 $2$ 个物品中选择：</p><script type="math/tex; mode=display">nums[1] \qquad \begin{array}{|c|c|c|c|c|}  \hline 1&2&1&0&0\\  \hline\end{array} \\ 选择\ nums[0]\ 或 \ nums[1] \ 都可以填满容量为\ 1\ 的背包，有\ 2\ 种方法\\同时选择\ nums[0]\ 和 \ nums[1] \ 填满容量为\ 2\ 的背包，只有这\ 1\ 种方法</script><p><em>以下选择情况同理，不再赘述，就是选择的元素进行组合。</em></p><p>从前 $3$ 个物品中选择：</p><script type="math/tex; mode=display">nums[2] \qquad \begin{array}{|c|c|c|c|c|}  \hline 1&3&3&1&0\\  \hline\end{array}</script><p>从前 $4$ 个物品中选择：</p><script type="math/tex; mode=display">nums[3] \qquad \begin{array}{|c|c|c|c|c|}  \hline 1&4&6&4&1\\  \hline\end{array}</script><p>从前 $5$ 个物品中选择：</p><script type="math/tex; mode=display">nums[4] \qquad \begin{array}{|c|c|c|c|c|}  \hline 1&5&10&10&5\\  \hline\end{array}</script><h3 id="golang代码实现-2"><a href="#golang代码实现-2" class="headerlink" title="golang代码实现"></a>golang代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 目标值比元素和还大，无解</span></span><br><span class="line">    <span class="comment">//2. 对 2 不能整除，无解。</span></span><br><span class="line">    <span class="comment">//因为进行的是整数加减法，不能整除的话就会向下取整，那么背包容量就会偏小于我们预期的容量，比如本示例的 target 如果等于 2，那么预期的背包重量就需要是 3.5，但进行的是整数加减法，不可能得到 3.5</span></span><br><span class="line">    <span class="keyword">if</span> target &gt; sum || (target + sum) % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算背包最大重量，防止溢出 (sum + target)/2 可能溢出</span></span><br><span class="line">    bag := sum - (sum - target) / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bag + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bag; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[bag]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">leetcode 474</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个二进制字符串数组 $strs$ 和两个整数 $m$ 和 $n$ 。</p><p>请你找出并返回 $strs$ 的最大子集的大小，该子集中最多 有 $m$ 个 $0$ 和 $n$ 个 $1$ 。</p><p>如果 $x$ 的所有元素也是 $y$ 的元素，集合 $x$ 是集合 $y$ 的子集 。</p><p>示例：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>], m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最多有 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 的最大子集是 &#123;<span class="string">"10"</span>,<span class="string">"0001"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>&#125; ，因此答案是 <span class="number">4</span> 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;<span class="string">"0001"</span>,<span class="string">"1"</span>&#125; 和 &#123;<span class="string">"10"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>&#125; 。&#123;<span class="string">"111001"</span>&#125; 不满足题意，因为它含 <span class="number">4</span> 个 <span class="number">1</span> ，大于 n 的值 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><p>与前面三道题相比，本题的特征就更加不明显了，不太容易理解并转化为 $01$ 背包问题。</p><p>$strs$ 就是物品列表，每一个字符串都是一个物品，它的价值就是 $1$，选了的话背包的总价值就 $+1$。但是物品对应的重量不再是一个单一的维度，而是它的内部包含的 $0$ 的个数和 $1$ 的个数两个维度。只要想通了这点，就把此问题转化成与前几道问题一样 $01$ 背包思想了。 </p><p>类似物品的重量，本题背包的容量也同样变为两个维度。</p><p><strong>$dp$ 数组定义</strong></p><p>使用一个二维 $dp$ 数组。</p><p>对于 $dp[i][j]$，$i$ 代表能选取物品中包含 $0$ 的最大数量，$j$ 代表能选取物品中包含 $1$ 的最大数量，$dp[i][j]$ 代表选取的物品中最多有 $i$ 个 $0$ ，$j$ 个 $1$ 的最大子集的大小。</p><p><strong>递推公式</strong></p><p>对于某个物品，假设它包含 $zeroNum$ 个 $0$， $oneNum$ 个 $1$。</p><p>对于 $dp[i][j]$，它可以由以下两个公式推出：</p><script type="math/tex; mode=display">\begin{align*}&dp[i][j] = dp[i][j]\\&dp[i][j] = dp[i - zeroNum][j - oneNum] + 1\end{align*}</script><p>因为当前物品包含的 $0$ 和 $1$ 的数量已经确定，那么 $dp[i - zeroNum][j - oneNum]$ 位置已经选取的子集大小也是确定，所以 $dp[i][j]$ 位置就是有足够的容量来选择当前物品的，所以最终结果只需在 $dp[i - zeroNum][j - oneNum]$ 的基础上 $+1$。</p><p>还有一种情况，在之前遍历某个物品时，已经对通过 $dp[i][j]= dp[i - zeroNum][j - oneNum] + 1$ 设置了值。</p><p>那么在遍历后续的物品时，对于此时的 $i$ 和 $j$ 对应的 $dp[i][j]$ 就可能出现一种情况：</p><script type="math/tex; mode=display">dp[i][j] \geq dp[i - zeroNum][j - oneNum] + 1</script><p>所以最终需要对这两种情况取最大值，与前几题也是十分类似的，但是细节不一样，需要好好理解。</p><p>所以最终的递推公式就是：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</script><p><strong>遍历方式</strong></p><p>与前几题一样，同样，先遍历物品，然后先计算出物品包含的 $0$ 和 $1$ 的数量。</p><p>然后遍历背包的容量（在这道题里就变为了 $m$ 和 $n$ 两个维度）。</p><p>因为本题的二维 $dp$ 数组不再是<strong>物品</strong>和<strong>背包重量</strong>构成的二维数组（回顾 $dp$ 数组定义）而是由物品的<strong>两个维度</strong>构成的。</p><p>那么也就是说本题 $dp$ 数组的推导过程不再是一行一行进行的</p><p><strong>举例推导</strong></p><p>以示例参数为例，推导过程如下：</p><script type="math/tex; mode=display">初始值 \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&0&0&0\\  \hline 包含1个0&0&0&0&0\\  \hline 包含2个0&0&0&0&0\\  \hline 包含3个0&0&0&0&0\\  \hline 包含4个0&0&0&0&0\\  \hline 包含5个0&0&0&0&0\\  \hline\end{array}</script><p>遍历到物品 $0$，也就是 $10$，它包含 $1$ 个 $0$ 和 $1$ 个 $1$</p><p>根据限制条件，遍历范围为 $dp[5][3]$ ~ $dp[1][1]$，对应位置变化如下：</p><script type="math/tex; mode=display">strs[0] \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&0&0&0\\  \hline 包含1个0&0&1&1&1\\  \hline 包含2个0&0&1&1&1\\  \hline 包含3个0&0&1&1&1\\  \hline 包含4个0&0&1&1&1\\  \hline 包含5个0&0&1&1&1\\  \hline\end{array}</script><p>遍历到物品 $1$，也就是 $0001$，它包含 $3$ 个 $0$ 和 $1$ 个 $1$</p><p>根据限制条件，遍历范围为 $dp[5][3]$ ~ $dp[3][1]$，以 $dp[5][3]$ 为例，取递推公式中两种情况的最大值：</p><script type="math/tex; mode=display">\begin{align*}    dp[5][3] &= max(dp[5][3], dp[5 - 3][3 - 1] + 1)\\             &= max(1, dp[2][2])\\             &= max(1, 1 + 1)\\             &= max(1, 2)\\             &= 2\\\end{align*}</script><p>其他步骤中同理，不再赘述，仅列出总体变化过程。</p><script type="math/tex; mode=display">strs[1] \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&0&0&0\\  \hline 包含1个0&0&1&1&1\\  \hline 包含2个0&0&1&1&1\\  \hline 包含3个0&0&1&1&1\\  \hline 包含4个0&0&1&2&2\\  \hline 包含5个0&0&1&2&2\\  \hline\end{array}</script><p>遍历到物品 $2$，也就是 $111001$，它包含 $2$ 个 $0$ 和 $4$ 个 $1$：</p><script type="math/tex; mode=display">strs[2] \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&0&0&0\\  \hline 包含1个0&0&1&1&1\\  \hline 包含2个0&0&1&1&1\\  \hline 包含3个0&0&1&1&1\\  \hline 包含4个0&0&1&2&2\\  \hline 包含5个0&0&1&2&2\\  \hline\end{array}</script><p>遍历到物品 $3$，也就是 $1$，它包含 $0$ 个 $0$ 和 $1$ 个 $1$：</p><script type="math/tex; mode=display">strs[3] \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&1&1&1\\  \hline 包含1个0&0&1&2&2\\  \hline 包含2个0&0&1&2&2\\  \hline 包含3个0&0&1&2&2\\  \hline 包含4个0&0&1&2&3\\  \hline 包含5个0&0&1&2&3\\  \hline\end{array}</script><p>遍历到物品 $4$，也就是 $0$，它包含 $1$ 个 $0$ 和 $0$ 个 $1$：</p><script type="math/tex; mode=display">strs[4] \qquad \begin{array}{|c|c|c|c|c|}  \hline        &包含0个1&包含1个1&包含2个1&包含3个1\\  \hline 包含0个0&0&1&1&1\\  \hline 包含1个0&1&2&2&2\\  \hline 包含2个0&1&2&3&3\\  \hline 包含3个0&1&2&3&3\\  \hline 包含4个0&1&2&3&3\\  \hline 包含5个0&1&2&3&4\\  \hline\end{array}</script><p>最终 $dp[m][n]$ 就是要题目要求的答案。</p><h3 id="golang代码实现-3"><a href="#golang代码实现-3" class="headerlink" title="golang代码实现"></a>golang代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="keyword">string</span>, m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//外层循环遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123; </span><br><span class="line">            <span class="comment">//计算当前遍历到的物品包含的 0 和 1 的数量</span></span><br><span class="line">        <span class="keyword">var</span> zeroNum, oneNum <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> str[i] == <span class="string">'0'</span> &#123;</span><br><span class="line">                zeroNum++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oneNum++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里的两层循环相当于前几题的一层内循环，因为本题的物品重量有 m 和 n 两个维度</span></span><br><span class="line">            <span class="comment">//而本题的 dp 数组就是由这两个维度构成的</span></span><br><span class="line">          <span class="comment">//对于每一个物品，都会根据它含有的 0 和 1 的数量去遍历 dp 数组的多行</span></span><br><span class="line">            <span class="comment">//对于 dp[i][j]，在遍历到某个物品时，当前位置可能已经在遍历前几个物品时被设置过了值，此时就需要取一下两种方式的最大值</span></span><br><span class="line">        <span class="keyword">for</span> i := m; i &gt;= zeroNum; i-- &#123;</span><br><span class="line">            <span class="keyword">for</span> j := n; j &gt;= oneNum; j-- &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i-zeroNum][j-oneNum]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="//sunxingboo.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>不使用加法计算两数之和</title>
    <link href="2021/07/13/bit-add/"/>
    <id>2021/07/13/bit-add/</id>
    <published>2021-07-12T16:00:00.000Z</published>
    <updated>2021-07-13T09:30:29.948Z</updated>
    
    <content type="html"><![CDATA[<p>举例两个数字的位图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 //0011</span><br><span class="line">1 //0001</span><br></pre></td></tr></table></figure><p>当相加时，每个位上都可能发生四种种情况：</p><ol><li>两个数对应的位都是 <em>0</em>，相加后仍然为 <em>0</em>。</li><li>两个数对应的位一个是 <em>1</em>，另一个是 <em>0</em>，相加后为 <em>1</em>。</li><li>两个数对应的位都是 <em>1</em>，相加后产生进位，结果为 <em>0</em></li><li>两个数对应的位一个是 <em>1</em>，另一个是 <em>0</em>。相加后为 <em>1</em>，然后接收到了下一位相加产生的进位 <em>1</em>，最终结果为 <em>0</em>，并且产生了一个进位 <em>1</em>。</li></ol><script type="math/tex; mode=display">\begin{array}{cc|c}           A&B&F\\    \hline 0&0&0\\           0&1&1\\           1&0&1\\           1&1&0\\\end{array}</script><p>若不考虑进位，只针对每一位来看，这就是一个异或操作。</p><a id="more"></a><p><strong>相加</strong></p><p>所以先不考虑进位，进行一次<strong>异或</strong>操作，得到的就是这两个数相加之后，每一个位不考虑进位的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 //0011</span><br><span class="line">1 //0001</span><br><span class="line"></span><br><span class="line">3 ^ 1 //0010</span><br></pre></td></tr></table></figure><p><strong>进位</strong></p><p>那么进位的情况怎么计算呢？</p><p>很简单，两个数对应的位都是 <em>1</em> 的时候，在相加之后这一位就会产生进位。</p><p>也就是两个数进行<strong>与</strong>操作，结果中为 <em>1</em> 的位<strong>将</strong>会发生进位。</p><p>例如在这个例子中，相加之后会产生进位的位置应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 //0011</span><br><span class="line">1 //0001</span><br><span class="line">3 &amp; 1 //0001</span><br></pre></td></tr></table></figure><p>而进位的结果是当前位变 <em>0</em> ，<em>1</em> 进到下一位上，也就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0010</span><br></pre></td></tr></table></figure><p>显然这是一个左移操作。</p><p><strong>求和</strong></p><p>现在只需要把这两部分整合到一起就可以加法结果。</p><p>但此时得到的两部分结果，相加之后同样可能发生进位。这里就需要先进行进位判断，也就是将两部分进行<strong>与</strong>操作，并判断结果是否为 <em>0</em>：</p><ul><li>当结果为 <em>0</em> 时就说明不会发生进位了</li><li>否则就继续对这两部分进行上述的<strong>相加</strong>和<strong>进位</strong>操作，得到对应的两部分结果，然后继续判断是否发生进位。</li></ul><p>最后在不会发生进位时，将这两部分结果进行<strong>异或</strong>操作，就得到了这两个数字的和。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0010 &amp; 0010        //0010 != 0 还会发生进位</span><br><span class="line"></span><br><span class="line">0010 ^ 0010        //0000 求不考虑进位相加后的结果</span><br><span class="line">(0010 &amp; 0010) &lt;&lt; 1 //0100 求相加后产生的进位结果</span><br><span class="line">0000 &amp; 0100        //0000 没有进位了</span><br><span class="line">0000 ^ 0100        //0100 最终结果</span><br></pre></td></tr></table></figure><p>经上述分析，将加法操作分成了三部分：</p><ol><li>两数<strong>异或</strong>，得到不考虑进位的结果。</li><li>两数<strong>与</strong>，得到只考虑进位后的结果。</li><li>第 <em>1</em> 步和第 <em>2</em> 步中得到两部分结果进行<strong>与</strong>。若会发生进位就对这两部分结果重复执行第 <em>1</em> 步和第 <em>2</em> 步；直到不会发生进位时，对这两部分求<strong>异或</strong>得到最终结果。</li></ol><p><strong>golang代码实现</strong> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  xor := a ^ b</span><br><span class="line">  and := (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (xor &amp; and) != <span class="number">0</span> &#123;</span><br><span class="line">    tmp := xor</span><br><span class="line">    xor ^= and</span><br><span class="line">    and = (tmp &amp; and) &lt;&lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xor ^ and</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举例两个数字的位图&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;3 //0011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 //0001&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当相加时，每个位上都可能发生四种种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个数对应的位都是 &lt;em&gt;0&lt;/em&gt;，相加后仍然为 &lt;em&gt;0&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;两个数对应的位一个是 &lt;em&gt;1&lt;/em&gt;，另一个是 &lt;em&gt;0&lt;/em&gt;，相加后为 &lt;em&gt;1&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;两个数对应的位都是 &lt;em&gt;1&lt;/em&gt;，相加后产生进位，结果为 &lt;em&gt;0&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;两个数对应的位一个是 &lt;em&gt;1&lt;/em&gt;，另一个是 &lt;em&gt;0&lt;/em&gt;。相加后为 &lt;em&gt;1&lt;/em&gt;，然后接收到了下一位相加产生的进位 &lt;em&gt;1&lt;/em&gt;，最终结果为 &lt;em&gt;0&lt;/em&gt;，并且产生了一个进位 &lt;em&gt;1&lt;/em&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\begin{array}{cc|c}
           A&amp;B&amp;F\\
    \hline 0&amp;0&amp;0\\
           0&amp;1&amp;1\\
           1&amp;0&amp;1\\
           1&amp;1&amp;0\\
\end{array}&lt;/script&gt;&lt;p&gt;若不考虑进位，只针对每一位来看，这就是一个异或操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="//sunxingboo.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01背包</title>
    <link href="2021/07/12/01pack/"/>
    <id>2021/07/12/01pack/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-08-04T07:09:17.695Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg" width="400" height="300"/></p><a id="more"></a><h2 id="简单理解-01-背包问题性质"><a href="#简单理解-01-背包问题性质" class="headerlink" title="简单理解 01 背包问题性质"></a>简单理解 01 背包问题性质</h2><p>每个物品的数量只有 $1$ 个，选择情况只有<strong>选</strong>和<strong>不选</strong>两种，就是 $01$ 背包。</p><p>暴力解法时间复杂度为 <strong>$O(2^n)$</strong>。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个背包，它最大能收纳的重量为 $packWeight$。</p><p>一组物品，每个物品只有一个，第 $i$ 个物品的重量为 $weights[i]$，它的价值为 $values[i]$。</p><p>就算背包能容纳的物品的最大价值。</p><script type="math/tex; mode=display">示例\ \ \\begin{array}{|c|c|c|c|}    \hline packWeight&4\\    \hline weights&1&3&4\\    \hline values&15&20&30\\    \hline\end{array}</script><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>总体可以理解为有两个维度的变量</p><ul><li>背包容量</li><li>物品数量</li></ul><p>假设物品共有 $i$ 个，背包的最大收纳重量为 $j$。</p><p>那么这个问题的答案就是从这 $i$ 个物品里任意选择若干个放入容量为 $j$ 背包，背包所能收纳的物品的最大价值。</p><p>在选择第 $i$ 个物品时，有两种情况（<strong>这两种情况是由两种不同的选择方案导致的</strong>）：</p><ul><li><p>对前面 $i - 1$ 个物品进行选择后，此时背包的剩余容量不够装下第 $i$ 个物品了（不选择第 $i$ 个物品）。也就是在这种选择方案下，$i$ 个物品和 $i - 1$ 个物品的最大价值是相同的。</p></li><li><p>剩余容量足够装下第 $i$ 个物品，那么它需要占用 $weights[i]$ 的容量。在这个选择方案中，其余的 $i - 1$ 个物品收纳在 $j - weights[i]$ 容量内（并不一定完全占满）。</p></li></ul><h2 id="二维-dp-数组"><a href="#二维-dp-数组" class="headerlink" title="二维 dp 数组"></a>二维 dp 数组</h2><p>可以维护一个二维 $dp$ 数组。</p><h3 id="数组下标定义"><a href="#数组下标定义" class="headerlink" title="数组下标定义"></a>数组下标定义</h3><p>$i$：在 $0$ ~ $i$ 范围内随意选择物品。</p><p>$j$：放入容量为 $j$ 的背包。</p><p>$dp[i][j]$：所有可能的选择方案中，物品最大的价值。</p><h3 id="递推公式及状态转移方程"><a href="#递推公式及状态转移方程" class="headerlink" title="递推公式及状态转移方程"></a>递推公式及状态转移方程</h3><p>通过上述分析，可以知道 $dp[i][j]$ 有两种情况。</p><p>递推公式如下：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}dp[i - 1][j]\\dp[i - 1][j - weights[i]] + values[i]\end{cases}</script><p>那么显然，$dp[i][j]$ 应该取两者的最大值。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], \ dp[i - 1][j - weights[i]] \ +values[i])</script><h3 id="初始化-dp-数组"><a href="#初始化-dp-数组" class="headerlink" title="初始化 dp 数组"></a>初始化 dp 数组</h3><p><strong>第一种初始化方式</strong></p><p>考虑这样一个二维数组的情况</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0\\    \hline 物品1\\    \hline 物品2\\    \hline\end{array}</script><p>对于第一列，也就是当背包最大容量为 $0$ 的时候，无论怎么选择物品，所能容纳的物品价值都将是 $0$。</p><p><em>所以将第 $1$ 列全部初始化为 $0$</em>。</p><p>对于第一行，也就是只从第 1 个物品中选择时，那么只要它的重量小于或等于背包的重量，那么最大价值就是第 1 个物品的重量，否则最大价值就是 0。</p><p><em>所以遍历第 $1$ 行，判断背包容量是否满足第一个物品，初始化对应的值。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= packWeight; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt;= weights[<span class="number">0</span>] &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = values[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&15&15&15&15\\    \hline 物品1 &0\\    \hline 物品2 &0\\    \hline\end{array}</script><p>这种初始化方式虽然比较直观，但是并没有利用到递推公式，这样的操作看上去使遍历 $dp$ 的过程割裂成了两种方式。</p><p><strong>第二种初始化方式</strong></p><p>更好的做法是在对整个 $dp$ 数组的赋值过程中，始终使用的是同一种方式。</p><p>根据递推公式，第一行的数据值的推导过程为：</p><script type="math/tex; mode=display">dp[0][j] = max(dp[0][j], dp[0][j - weights[0]] + values[0])</script><p>那么这样初始化是否可以呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = max(dp[<span class="number">0</span>][j], dp[<span class="number">0</span>][j - weights[<span class="number">0</span>]] + values[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一下初始化结果发现是不对的：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&15&30&45&60\\    \hline 物品1 &0\\    \hline 物品2 &0\\    \hline\end{array}</script><p>但是物品 $0$ 只有一个，第一行的数据应该只有两种可能的值：</p><ol><li>背包重量 $j$ 装不下物品 $0$，初始化为 $0$。</li><li>背包重量 $j$ 可以装下物品 $0$，初始化为 $values[0]$。</li></ol><p><em>但当使用上述方式初始化时，物品会被重复选用</em>。</p><p>因为遍历到每一个位置，也就是 $dp[0][j]$ 时，当前位置此时还没有初始化，值是 $0$。所以最终取的结果值就是 $dp[0][j - weights[i]] + values[i]$，而 $dp[0][j - weights[i]]$ 指向的是刚刚已经初始化过的位置的值，再加上当前物品（物品 $0$）的价值。</p><p>例如当 $j = 2$ 时：</p><script type="math/tex; mode=display">\begin{aligned}dp[0][2] &= max(dp[0][2], dp[0][2 - weights[0]] + values[0])\\         &= dp[0][2 - weights[0]] + values[0]\\         &= dp[0][1] + values[0]\\         &= 15 + 15\\         &= 30\end{aligned}</script><p>这是由于递推公式依赖当前位置同行的前面某个位置的值，这就导致了重复。那么可以逆序遍历，这样遍历到当前位置时，它的前面的位置都还没有初始化，就不会导致重复了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j := packWeight; j &gt;= <span class="number">1</span>; j-- &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = max(dp[<span class="number">0</span>][j], dp[<span class="number">0</span>][j - weights[<span class="number">0</span>]] + values[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>考虑递推公式的两种情况，对于当前遍历到的位置 $dp[i][j]$，它依赖的数据位置下标为 $i - 1$，$j$ 和 $j - weights[i]$。</p><p>都是小于当前位置下标的。</p><p>所以利用状态转移方程处理剩余 $dp$ 数组位置时，即可以横向遍历，页可以纵向遍历（横向遍历，也就是先遍历物品选择范围的方式更容易理解）。</p><h3 id="举例推导验证"><a href="#举例推导验证" class="headerlink" title="举例推导验证"></a>举例推导验证</h3><p>按上述分析的规律举例推导一下 $dp$ 数组，看是否满足。</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&15&15&15&15\\    \hline 物品1 &0&15&15&20&35\\    \hline 物品2 &0&15&15&20&35\\    \hline\end{array}</script><h3 id="golang-代码实现"><a href="#golang-代码实现" class="headerlink" title="golang 代码实现"></a>golang 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weights = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> values = []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroOnePack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  n := <span class="built_in">len</span>(weights)</span><br><span class="line">  dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= packWeight; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> i &gt;= weights[<span class="number">0</span>] &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i] = values[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算dp数组的其他位置</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">          <span class="keyword">if</span> j &lt; weights[i] &#123;</span><br><span class="line">              dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weights[i]] + values[i])</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种遍历方式是，当 $j - weights[i]$ 小于 $0$ 时，不做处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= weights[i] &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weights[i]] + values[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理后的结果为：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&15&15&15&15\\    \hline 物品1 &0&0&0&20&35\\    \hline 物品2 &0&0&0&0&35\\    \hline\end{array}</script><p>与上述另一个遍历版本相比，这里差异的几个位置为 $0$ ，这些位置实际是用不上的。</p><h2 id="一维-dp-数组"><a href="#一维-dp-数组" class="headerlink" title="一维 dp 数组"></a>一维 dp 数组</h2><p>由上述二维 $dp$ 数组观察可知，实际需要的是最后一个元素，并且推导过程是一行一行进行的。</p><p>所以实际上只需要维护一行就可以了，遍历推导下一行时直接覆盖到上一行对应的位置，因此维护一个一维 $dp$ 数组就可以了。</p><p>整体思路与二维 $dp$ 数组时一致的，简单列举一下数据变化过程帮助理解：</p><p>维护一个一维数组</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&0&0&0&0\\    \hline\end{array}</script><p>与二维 $dp$ 数组同样的初始化</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&15&15&15&15\\    \hline\end{array}</script><p>遍历处理物品 $1$ 时，不再是二维数组的第二行，而是直接覆盖在这个一维 $dp$ 数组上</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品1 &0&15&15&20&35\\    \hline\end{array}</script><p>遍历处理物品 $2$</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品2 &0&15&15&20&35\\    \hline\end{array}</script><p><strong>golang 代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroOnePack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  n := <span class="built_in">len</span>(weights)</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= packWeight; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> i &gt;= weights[<span class="number">0</span>] &#123;</span><br><span class="line">          dp[i] = values[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算dp数组的其他位置</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= packWeight; j++ &#123;</span><br><span class="line">          <span class="keyword">if</span> j &gt;= weights[i] &#123;</span><br><span class="line">              dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现是有问题的，只是对于这个示例来说，可以通过。</p><p>使用一维 $dp$ 数组，实际上就要考虑采用上述第二种初始化方式时遇到的问题，会发生<strong>重复</strong>选择物品的情况。</p><p>来看这样一个例子：</p><script type="math/tex; mode=display">示例\ \ \\begin{array}{|c|c|c|c|}    \hline bagWeight&4\\    \hline weights&1&2&5\\    \hline values&1&2&5\\    \hline\end{array}</script><p>初始状态：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&0&0&0&0\\    \hline\end{array}</script><p>初始化后：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品0 &0&1&1&1&1\\    \hline\end{array}</script><p>第 $2$ 行：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品1 &0&1&2&3&4\\    \hline\end{array}</script><p>第 $3$ 行：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品2 &0&1&2&3&4\\    \hline\end{array}</script><p>显然在最后一个单元格发生了重复，正常是不可能出现 $4$ 的。</p><p>这是因为 $j = 4$ 时：</p><script type="math/tex; mode=display">\begin{align}dp[4] &= max(dp[4], dp[4 - weights[1]] + values[1])\\      &= max(1, dp[2] + 2)\\      &= max(1, 2 + 2)\\      &= 4\end{align}</script><p>而 $dp[2]$ 位置就已经选择了物品 $1$，$dp[4]$ 在 $dp[2]$ 的基础上又重复选择了一次。</p><p>在使用二维 $dp$ 数组时不会发生这种情况，因为遍历下一行时不会去覆盖上一行的数据。</p><p>那么这里为了不发生重复，就要使用在第二种初始化方式中讨论过的技巧，逆序遍历。</p><p>在逆序情况下，正确的情况应该是，在遍历 $dp[4]$ 时，$dp[2]$ 的是 $1$ 而不是 $2$ （这就是在问题分析中说的：选物品 $1$ 时，扣除物品 $1$ 的重量以外，剩余的背包重量在除物品 $1$ 以外剩余可选的物品中，能选择的最大值。此时剩余的重量并不一定会装满。）：</p><script type="math/tex; mode=display">\begin{align}dp[4] &= max(dp[4], dp[4 - weights[1]] + values[1])\\      &= max(1, dp[2] + 2)\\      &= max(1, 1 + 2)\\      &= 3\end{align}</script><p>第 $2$ 行：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品1 &0&1&2&3&3\\    \hline\end{array}</script><p>第 $3$ 行：</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|}    \hline     &重量0&重量1&重量2&重量3&重量4\\    \hline 物品1 &0&1&2&3&3\\    \hline\end{array}</script><p><strong>golang代码实现</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroOnePack</span><span class="params">(packWeight <span class="keyword">int</span>, weights, values []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  n := <span class="built_in">len</span>(weights)</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, packWeight + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> j := packWeight; j &gt;= weights[<span class="number">0</span>]; j-- &#123;</span><br><span class="line">    dp[j] = max(dp[j], dp[j - weights[<span class="number">0</span>]] + values[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算dp数组的其他位置</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := packWeight; j &gt;= weights[i]; j-- &#123;</span><br><span class="line">          dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(dp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[packWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/algorithm/dp/pack.jpeg&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="//sunxingboo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="//sunxingboo.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用数学公式代码</title>
    <link href="2021/07/09/markdown-math/"/>
    <id>2021/07/09/markdown-math/</id>
    <published>2021-07-08T16:00:00.000Z</published>
    <updated>2021-08-04T02:28:55.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上-下角标"><a href="#上-下角标" class="headerlink" title="上/下角标"></a>上/下角标</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$x^2$</td><td>x^2</td></tr><tr><td>$x_i$</td><td>x_i</td></tr><tr><td>$x_i^2$</td><td>x^2_i<br/>x_i^2</td></tr></tbody></table></div><a id="more"></a><h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\frac{n-m}{m}$</td><td>\frac{n-m}{m}</td></tr></tbody></table></div><h2 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a>开根号</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\sqrt{2}$</td><td>\sqrt{2}</td></tr></tbody></table></div><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\vec{a}$</td><td>\vec{a}</td></tr></tbody></table></div><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\int{x}dx$</td><td>\int{x}dx</td></tr><tr><td>$\int_{1}^{2}{x}dx$</td><td>\int_{1}^{2}{x}dx</td></tr></tbody></table></div><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\lim{a+b}$</td><td>\lim{a+b}</td></tr><tr><td>$\lim_{n\rightarrow+\infty}$</td><td>\lim_{n\rightarrow+\infty}</td></tr></tbody></table></div><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\sum{a}$</td><td>\sum{a}</td></tr><tr><td>$\sum_{n=1}^{100}{a_n}$</td><td>\sum_{n=1}^{100}{a_n}</td></tr></tbody></table></div><h2 id="求积"><a href="#求积" class="headerlink" title="求积"></a>求积</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\prod{x}$</td><td>\prod{x}</td></tr><tr><td>$\prod_{n=1}^{99}{x_n}$</td><td>\prod_{n=1}^{99}{x_n}</td></tr></tbody></table></div><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\sin{\theta}$</td><td>\sin{\theta}</td></tr><tr><td>$\cos{\theta}$</td><td>\cos{\theta}</td></tr><tr><td>$\tan{\theta}$</td><td>\tan{\theta}</td></tr><tr><td>$\cot{\theta}$</td><td>\cot{\theta}</td></tr></tbody></table></div><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\ln2$</td><td>\ln2</td></tr><tr><td>$\log_28$</td><td>\log_28</td></tr><tr><td>$\lg10$</td><td>\lg10</td></tr></tbody></table></div><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container"><table><thead><tr><th>大写</th><th>Markdown</th><th>小写</th><th>Markdown</th></tr></thead><tbody><tr><td>$A$</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>$B$</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>$E$</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td></td><td></td><td>$\varepsilon$</td><td>\varepsilon</td></tr><tr><td>$Z$</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>$H$</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>$I$</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>$K$</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>$M$</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>$N$</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>$O$</td><td>O</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>$P$</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>$T$</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td></td><td></td><td>$\varphi$</td><td>\varphi</td></tr><tr><td>$X$</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\pm$</td><td>\pm</td></tr><tr><td>$\times$</td><td>\times</td></tr><tr><td>$\cdot$</td><td>\cdot</td></tr><tr><td>$\div$</td><td>\div</td></tr><tr><td>$\neq$</td><td>\neq</td></tr><tr><td>$\equiv$</td><td>\equiv</td></tr><tr><td>$\leq$</td><td>\leq</td></tr><tr><td>$\geq$</td><td>\geq</td></tr><tr><td>$\cap$</td><td>\cap</td></tr><tr><td>$\cup$</td><td>\cup</td></tr><tr><td>$\approx$</td><td>\approx</td></tr><tr><td>$\emptyset$</td><td>\emptyset</td></tr><tr><td>$\in$</td><td>\in</td></tr><tr><td>$\notin$</td><td>\notin</td></tr><tr><td>$\subset$</td><td>\subset</td></tr><tr><td>$\supset$</td><td>\supset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\supseteq$</td><td>\supseteq</td></tr><tr><td>$\bigvee$</td><td>\bigvee</td></tr><tr><td>$\bigwedge$</td><td>\bigwedge</td></tr><tr><td>$\biguplus$</td><td>\biguplus</td></tr><tr><td>$\bigsqcup$</td><td>\bigsqcup</td></tr></tbody></table></div><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\forall$</td><td>\forall</td></tr><tr><td>$\infty$</td><td>\infty</td></tr><tr><td>$\emptyset$</td><td>\emptyset</td></tr><tr><td>$\exists$</td><td>\exists</td></tr><tr><td>$\nabla$</td><td>\nabla</td></tr><tr><td>$\bot$</td><td>\bot</td></tr><tr><td>$\angle$</td><td>\angle</td></tr><tr><td>$\because$</td><td>\because</td></tr><tr><td>$\therefore$</td><td>\therefore</td></tr><tr><td>$\cdots$</td><td>\cdots</td></tr><tr><td>$\vdots$</td><td>\vdots</td></tr><tr><td>$\ddots$</td><td>\ddots</td></tr></tbody></table></div><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><div class="table-container"><table><thead><tr><th>表达式</th><th>Markdown</th><th>表达式</th><th>Markdown</th></tr></thead><tbody><tr><td>$\leftarrow$</td><td>\leftarrow</td><td>$\longleftarrow$</td><td>\longleftarrow</td></tr><tr><td>$\rightarrow$</td><td>\rightarrow</td><td>$\longrightarrow$</td><td>\longrightarrow</td></tr><tr><td>$\leftrightarrow$</td><td>\leftrightarrow</td><td>$\longleftrightarrow$</td><td>\longleftrightarrow</td></tr><tr><td>$\Leftarrow$</td><td>\Leftarrow</td><td>$\Longleftarrow$</td><td>\Longleftarrow</td></tr><tr><td>$\Rightarrow$</td><td>\Rightarrow</td><td>$\Longrightarrow$</td><td>\Longrightarrow</td></tr><tr><td>$\Leftrightarrow$</td><td>\Leftrightarrow</td><td>$\Longleftrightarrow$</td><td>\Longleftrightarrow</td></tr></tbody></table></div><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><script type="math/tex; mode=display">\begin{matrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{matrix} \tag{1}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; \tag&#123;1&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left|\begin{matrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{matrix} \right| \tag{2}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left|</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right| \tag&#123;2&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left\{\begin{matrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{matrix} \right\} \tag{3}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right\&#125; \tag&#123;3&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left[\begin{matrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{matrix} \right] \tag{4}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right] \tag&#123;4&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left(\begin{matrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{matrix} \right) \tag{5}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right) \tag&#123;5&#125;</span><br></pre></td></tr></table></figure><h2 id="简易表格"><a href="#简易表格" class="headerlink" title="简易表格"></a>简易表格</h2><script type="math/tex; mode=display">\begin{array}{|c|c|c|}    \hline 2&9&4\\    \hline 7&5&3\\    \hline 6&1&8\\    \hline\end{array}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;|c|c|c|&#125;</span><br><span class="line">  \hline 2&amp;9&amp;4\\</span><br><span class="line">  \hline 7&amp;5&amp;3\\</span><br><span class="line">  \hline 6&amp;1&amp;8\\</span><br><span class="line">  \hline</span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure><p>垂直线和单元格用<code>|c|c|c|</code>定义，水平线和单元格用<code>\hline</code>定义。</p><h2 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h2><script type="math/tex; mode=display">\begin{array}{cc|c}           A&B&F\\    \hline 0&0&0\\           0&1&1\\           1&0&1\\           1&1&1\\\end{array}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">         A&amp;B&amp;F\\</span><br><span class="line">  \hline 0&amp;0&amp;0\\</span><br><span class="line">         0&amp;1&amp;1\\</span><br><span class="line">         1&amp;0&amp;1\\</span><br><span class="line">         1&amp;1&amp;1\\</span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><script type="math/tex; mode=display">\begin{align*}\label{2}  & X(0) = x(0)W_{N}^{0\cdot0} + x(1)W_{N}^{0\cdot1} + \cdots + x(N-1)W_{N}^{0\cdot(N-1)}\\  & X(1) = x(0)W_{N}^{1\cdot0} + x(1)W_{N}^{1\cdot1} + \cdots + x(N-1)W_{N}^{1\cdot(N-1)} \\  & \cdots \\  & X(N-1) = x(0)W_{N}^{(N-1)\cdot0} + x(1)W_{N}^{(N-1)\cdot1} + \cdots + x(N-1)W_{N}^{(N-1)\cdot(N-1)} \\\end{align*}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;\label&#123;2&#125;</span><br><span class="line">  &amp; X(0) &#x3D; x(0)W_&#123;N&#125;^&#123;0\cdot0&#125; + x(1)W_&#123;N&#125;^&#123;0\cdot1&#125; + \cdots + x(N-1)W_&#123;N&#125;^&#123;0\cdot(N-1)&#125;\\</span><br><span class="line">  &amp; X(1) &#x3D; x(0)W_&#123;N&#125;^&#123;1\cdot0&#125; + x(1)W_&#123;N&#125;^&#123;1\cdot1&#125; + \cdots + x(N-1)W_&#123;N&#125;^&#123;1\cdot(N-1)&#125; \\</span><br><span class="line">  &amp; \cdots \\</span><br><span class="line">  &amp; X(N-1) &#x3D; x(0)W_&#123;N&#125;^&#123;(N-1)\cdot0&#125; + x(1)W_&#123;N&#125;^&#123;(N-1)\cdot1&#125; + \cdots + x(N-1)W_&#123;N&#125;^&#123;(N-1)\cdot(N-1)&#125; \\</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{aligned}a &= b + c \\  &= d + e + f\end{aligned}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp;&#x3D; b + c \\</span><br><span class="line">  &amp;&#x3D; d + e + f</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><script type="math/tex; mode=display">\begin{cases}3x + 5y +  z \\7x - 2y + 4z \\-6x + 3y + 2z\end{cases}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125;</span><br><span class="line">3x + 5y +  z \\</span><br><span class="line">7x - 2y + 4z \\</span><br><span class="line">-6x + 3y + 2z</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">f(n) =\begin{cases} n/2,  & \text{if }n\text{ is even} \\3n+1, & \text{if }n\text{ is odd}\end{cases}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D;</span><br><span class="line">\begin&#123;cases&#125; </span><br><span class="line">n&#x2F;2,  &amp; \text&#123;if &#125;n\text&#123; is even&#125; \\</span><br><span class="line">3n+1, &amp; \text&#123;if &#125;n\text&#123; is odd&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><h2 id="格式化字符"><a href="#格式化字符" class="headerlink" title="格式化字符"></a>格式化字符</h2><div class="table-container"><table><thead><tr><th>Markdown</th><th>说明</th></tr></thead><tbody><tr><td>\\</td><td>换行</td></tr><tr><td>&amp;</td><td>对齐</td></tr><tr><td>\!</td><td>紧</td></tr><tr><td>\,</td><td>小空格</td></tr><tr><td>\;</td><td>中空格</td></tr><tr><td>\</td><td>大空格</td></tr><tr><td>\quad</td><td>真空格</td></tr><tr><td>\qquad</td><td>双真空格</td></tr></tbody></table></div><script type="math/tex; mode=display">a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b</span><br></pre></td></tr></table></figure><h2 id="hexo-增加公式渲染依赖"><a href="#hexo-增加公式渲染依赖" class="headerlink" title="hexo 增加公式渲染依赖"></a>hexo 增加公式渲染依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;上-下角标&quot;&gt;&lt;a href=&quot;#上-下角标&quot; class=&quot;headerlink&quot; title=&quot;上/下角标&quot;&gt;&lt;/a&gt;上/下角标&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;Markdown&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$x^2$&lt;/td&gt;
&lt;td&gt;x^2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$x_i$&lt;/td&gt;
&lt;td&gt;x_i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$x_i^2$&lt;/td&gt;
&lt;td&gt;x^2_i&lt;br/&gt;x_i^2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
    
      <category term="markdown" scheme="//sunxingboo.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>记录 hexo 生成代码块间隙过大的问题解决</title>
    <link href="2021/07/08/hero-code/"/>
    <id>2021/07/08/hero-code/</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2021-07-12T09:06:57.467Z</updated>
    
    <content type="html"><![CDATA[<p><code>npm</code> 更新了依赖包之后发现文章生成的代码块的间隙变得很大，排查之后发现是由于 <code>hexo</code> 版本导致，原来使用的是 <code>4.2.1</code> 版本，被更新成了 <code>4.0.0</code> 版本，修改根目录下 <code>package.json</code> 文件后问题解决，记录备忘。</p><a id="more"></a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">     <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">     <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">       <span class="attr">"build"</span>: <span class="string">"hexo generate"</span>,</span><br><span class="line">       <span class="attr">"clean"</span>: <span class="string">"hexo clean"</span>,</span><br><span class="line">       <span class="attr">"deploy"</span>: <span class="string">"hexo deploy"</span>,</span><br><span class="line">       <span class="attr">"server"</span>: <span class="string">"hexo server"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"4.2.1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"hexo"</span>: <span class="string">"^4.2.1"</span>,</span><br><span class="line">      <span class="attr">"hexo-deployer-git"</span>: <span class="string">"^2.1.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-deployer-rsync"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-filter-mermaid-diagrams"</span>: <span class="string">"^1.0.5"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-baidu-sitemap"</span>: <span class="string">"^0.1.6"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-category"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-feed"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-index"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-json-content"</span>: <span class="string">"^4.1.6"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-sitemap"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-renderer-kramed"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">      <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^1.1.0"</span>,</span><br><span class="line">      <span class="attr">"hexo-server"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;npm&lt;/code&gt; 更新了依赖包之后发现文章生成的代码块的间隙变得很大，排查之后发现是由于 &lt;code&gt;hexo&lt;/code&gt; 版本导致，原来使用的是 &lt;code&gt;4.2.1&lt;/code&gt; 版本，被更新成了 &lt;code&gt;4.0.0&lt;/code&gt; 版本，修改根目录下 &lt;code&gt;package.json&lt;/code&gt; 文件后问题解决，记录备忘。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="//sunxingboo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>摩尔投票算法</title>
    <link href="2021/07/06/mole-vote/"/>
    <id>2021/07/06/mole-vote/</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-07-16T02:33:42.648Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一道算法题：</p><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1</p><p>示例 ：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>看到这个题目第一想法是，先将数组排序，然后取数组中间值。因为超过数组半数的元素在排序之后必然会占据中点位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(nlogn)</strong>，就是排序算法的时间复杂度。</p><p>空间复杂度为<strong>O(1)</strong>。</p><p>但是这个实现只能处理存在主要元素的样本。</p><p>例如当样本为<code>[1, 2, 3]</code>时，不存在主要元素，求中点得到的结果就是错误的。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>也可以使用哈希表来统计元素的出现次数，然后遍历哈希表找到数量超出数组半数的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        m[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; n / <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(n)</strong>。</p><p>空间复杂度为<strong>O(n)</strong>。</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>第三种方法就是本篇的主题，<strong>摩尔投票算法</strong>。</p><p>直接看算法名字的话有一些迷惑，但其实很好理解，把每个数字理解为一个参选者，数字出现的次数就是投给这个参选者的票数。</p><p>超过 1/2 的数字最多只可能有一个，每次找到两张不同的选票，将这两张选票消除，这个操作有两种情况：</p><ul><li>两张中有一张是超过 1/2 的选票</li><li>两张都是少数的选票</li></ul><p>消除后超过 1/2 的选票还是超过总数的 1/2。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//major就是待抵消的数字，count代表major这个数字的数量</span></span><br><span class="line">    <span class="comment">//就是相当于一个栈，入栈的是待抵消的数字，当下一个数字更这个数字相同时，继续入栈（count++），不同时则出栈（count--）</span></span><br><span class="line">    <span class="comment">//当栈为空时，当前遍历到的数字就定义为待抵消的数字，入栈（赋值给major，count++）</span></span><br><span class="line">    major, count := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">//没有需要抵消的元素，选中当前值，然后继续遍历</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            major = v</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有需要抵消的值，但是和当前遍历到的值相同，增加计数器（代表需要抵消的值的数量+1）</span></span><br><span class="line">        <span class="keyword">if</span> major == v &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有需要抵消的值，且和当前遍历到的值不同，则计数器-1（代表需要抵消的值的数量-1，major的值并不改变，在count减到0之后再遍历到新的值时才会改变）</span></span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩余待消除的值，再遍历一边校验一下这个值的数量是否真的超过半数</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">int</span> </span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> v == major &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(nums) / <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> major</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(n)</strong>。</p><p>空间复杂度为<strong>O(1)</strong>。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>考虑超过 1/3 的情况</strong></p><p>找到三个不同的值消除，同样有两种情况：</p><ul><li>其中有一个是我们要找的那个超过 1/3 选票</li><li>三个都不是我们要找的</li></ul><p>如果抵消的三个值都不是我们要找的，那么显然原本已经占比超过 1/3 的选票，在这轮操作之后将占比更高。</p><p>对于第一种情况，我们来简单证明一下。</p><p>有一类选票（同一个数值）超过总数的 1/3，我们假设它的数量是 m，总数是 n：</p><script type="math/tex; mode=display">\begin{align*}& 初始值 \begin{cases} m, （多数选票）\\ n-m,（其余选票） \end{cases}, \frac{n-m}{m}<\frac{\frac{2}{3}}{\frac{1}{3}} \Leftrightarrow \frac{n-m}{m}<2\\& \Rightarrow \frac{(n-m)-2}{m-1}<2\\& \Rightarrow (n-m)-2<2(m-1)\\& \Rightarrow n<3m\\& \Rightarrow m>\frac{n}{3}\\\end{align*}</script><p>所以对于这种情况，只需要维护 2 个计数器和对应的值来抵消选票：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  one, oneCount, two, twoCount := <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> oneCount == <span class="number">0</span> &#123;</span><br><span class="line">      one = v</span><br><span class="line">      oneCount++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> twoCount == <span class="number">0</span> &#123;</span><br><span class="line">      two = v</span><br><span class="line">      twoCount++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> one == v &#123;</span><br><span class="line">      oneCount++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> two == v &#123;</span><br><span class="line">      twoCount++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    oneCount--</span><br><span class="line">    twoCount--</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> oneCount &gt; <span class="number">0</span> &amp;&amp; check(one, nums) &#123;</span><br><span class="line">    <span class="keyword">return</span> one</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> twoCount &gt; <span class="number">0</span> &amp;&amp; check(two, nums) &#123;</span><br><span class="line">    <span class="keyword">return</span> two</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(i <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> v == i &#123;</span><br><span class="line">      sum++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="number">3</span> * sum &gt; <span class="built_in">len</span>(nums)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再推广到 1/k 的情况</strong></p><p>也是同样的道理，给出证明：</p><script type="math/tex; mode=display">\begin{align*}& 初始值 \begin{cases} m, （多数选票）\\ n-m,（其余选票） \end{cases}, \frac{n-m}{m}<\frac{1 - \frac{1}{k}}{\frac{1}{k}} \Leftrightarrow \frac{n-m}{m}<k-1\\& \Rightarrow \frac{(n-m)-(k-1)}{m-1}<k-1\\& \Rightarrow (n-m)-(k-1)<(m-1)(k-1)\\& \Rightarrow n-m<m(k-1)\\& \Rightarrow n<km\\& \Rightarrow m>\frac{n}{k}\\\end{align*}</script><p>这时只需要维护 k-1 个计数器和对应的值来遍历数组就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看一道算法题：&lt;/p&gt;
&lt;p&gt;数组中占比超过一半的元素称之为主要元素。给定一个&lt;strong&gt;整数&lt;/strong&gt;数组，找到它的主要元素。若没有，返回-1&lt;/p&gt;
&lt;p&gt;示例 ：&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>右移一位和除2的区别</title>
    <link href="2021/06/25/move-bit/"/>
    <id>2021/06/25/move-bit/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-07-12T09:06:57.467Z</updated>
    
    <content type="html"><![CDATA[<p>翻看<code>golang</code>源码的时候看到在本可以进行除 2 的地方，实际实现写的是右移一位，因而有了这里的思考。</p><p>那么右移一位和除 2 在不考虑性能的情况下，有什么区别呢？</p><a id="more"></a><p>先看两个示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">5</span> / <span class="number">2</span>)   <span class="comment">//2</span></span><br><span class="line"><span class="built_in">println</span>(<span class="number">-5</span> / <span class="number">2</span>) <span class="comment">//-2</span></span><br></pre></td></tr></table></figure><p>除法表现出来的现象是<strong>向 0 取整</strong>的。</p><p>再来看一下右移：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">5</span> &gt;&gt; <span class="number">1</span>)   <span class="comment">//2</span></span><br><span class="line"><span class="built_in">println</span>(<span class="number">-5</span> &gt;&gt; <span class="number">1</span>) <span class="comment">//-3</span></span><br></pre></td></tr></table></figure><p>这里就出现了差异，可以看出负奇数的右移是<strong>向下取整</strong>的。</p><p>那这种表象是什么原因呢？这就涉及到负数的二进制表示。</p><p>负数在计算机中的表示是其补码的形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-5的二进制表示，最高位位符号位</span></span><br><span class="line">10000101 #原码</span><br><span class="line">11111010 #反码</span><br><span class="line">11111011 #补码</span><br></pre></td></tr></table></figure><p>实际参与运算的也是补码，所以 -5 右移一位结果就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">println(-5 &gt;&gt; 1)</span></span><br><span class="line">11111011 #补码</span><br><span class="line">11111101 #补码右移一位</span><br><span class="line">11111100 #反码</span><br><span class="line">10000011 #原码</span><br></pre></td></tr></table></figure><p>右移操作完成后，再将补码转会原码就可以发现，结果是 -3。</p><p>在这里右移操作后左侧位是补 1 的。</p><p>位移操作分为两种：<strong>逻辑移位</strong>和<strong>算数移位</strong>。</p><p>对于左移来说，这两者是相同的，均是移除左边界的那些位丢失，右边空出来的补 0 。</p><p>对于右移，情况则不同，<strong>逻辑右移</strong>是在左侧补 0 ；而<strong>算数右移</strong>左侧补入的位取决于数值本身的符号，整数的最高位为 0 （正数），则移入位补 0  ；最高位为 1 （负数），则移入位补 1 。</p><p>算数右移具体采用哪种方式取决于编译器的具体实现，可以写一个 demo 程序去测试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻看&lt;code&gt;golang&lt;/code&gt;源码的时候看到在本可以进行除 2 的地方，实际实现写的是右移一位，因而有了这里的思考。&lt;/p&gt;
&lt;p&gt;那么右移一位和除 2 在不考虑性能的情况下，有什么区别呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="//sunxingboo.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="2020/07/18/trie/"/>
    <id>2020/07/18/trie/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2021-07-09T10:31:12.597Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">graph TB    A((.))    B((.))    C((.))    D((.))    E((.))    F((.))    G((.))    H((.))    I((.))    J((.))    A--t-->B    B--e-->C    C--s-->D    D--t-->E    B--r-->F    F--e-->G    G--e-->H    F--i-->I    I--e-->J</pre><p>字典树，也叫前缀树。典型应用是用于统计和排序大量字符串、搜素引擎输入关键词提示可能的选项。</p><p>它能最大限度的减少无谓的字符串比较。</p><a id="more"></a><h2 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h2><p>这里先用<code>golang</code>实现字典树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">  Next [<span class="number">26</span>]*Trie</span><br><span class="line">  IsEnd <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的每个节点有 26 个子节点，根据字符向下生长，叶子节点会有终点标识，到这里对一个单词的查账就结束了。</p><p>如果字符串的某一个字符没有查到，或者遍历完整个字符串，但是没有达到字典树的叶子节点，也就说明这个字符串在树中不存在。</p><p>简单实现插入和搜索方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Insert</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  curNode := t</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str) ;i++ &#123;</span><br><span class="line">    idx := <span class="keyword">int</span>(str[i] - <span class="string">'a'</span>)<span class="comment">//计算字符在26个子节点中的位置</span></span><br><span class="line">    <span class="keyword">if</span> curNode.Next[idx] == <span class="literal">nil</span> &#123;</span><br><span class="line">      curNode.Next[idx] = &amp;Trie&#123;</span><br><span class="line">        Next: [<span class="number">26</span>]*Trie&#123;&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode = curNode.Next[idx]<span class="comment">//切换节点，继续插入下一个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  curNode.sEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Search</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> str == <span class="string">""</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  curNode := t</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">    idx := <span class="keyword">int</span>(str[i] - <span class="string">'a'</span>)<span class="comment">//计算偏移量</span></span><br><span class="line">    <span class="keyword">if</span> curNode.Next[idx] == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//字符不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    curNode = curNode.Next[idx]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !curNode.IsEnd &#123; <span class="comment">//遍历完字符串，但没有达到叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>最近<code>leetcode</code>的每日一题中遇到一道使用字典树的题目：</p><blockquote><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p><p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p><p>示例：</p><p>输入：<br>dictionary = [“looked”,”just”,”like”,”her”,”brother”]<br>sentence = “jesslookedjustliketimherbrother”<br>输出： 7<br>解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。<br>提示：</p><p>0 &lt;= len(sentence) &lt;= 1000<br>dictionary中总字符数不超过 150000。<br>你可以认为dictionary和sentence中只包含小写字母。</p></blockquote><p>这里就是利用<code>trie</code>通过字典<code>dictionary</code>生成一颗倒叙的字典树，然后我们遍历<code>sentence</code>字符串，直到匹配跟节点的时候，再从此处向前遍历字符查找字典树，以此来判断单词是否存在，这样能规避无谓的字符比较。</p><pre class="mermaid">graph TB    A((.))    B((.))    C((.))    D((.))    E((.))    F((.))    G((.))    H((.))    I((.))    J((.))    K((.))    L((.))    M((.))    N((.))    O((.))    P((.))    Q((.))    U((.))    V((.))    W((.))    X((.))    A--d-->B    B--e-->C    C--k-->D    D--0-->E    E--0-->F    F--l-->G    A--t-->H    H--s-->I    I--u-->J    J--j-->K    A--e-->L    L--k-->M    M--i-->N    N--l-->O    A--r-->P    P--e-->Q    Q--h-->U    U--t-->V    V--0-->W    W--b-->X</pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respace</span><span class="params">(dictionary []<span class="keyword">string</span>, sentence <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">//文章长度</span></span><br><span class="line">    n := <span class="built_in">len</span>(sentence)</span><br><span class="line">    <span class="comment">//初始化字典树</span></span><br><span class="line">  root := &amp;Trie&#123;</span><br><span class="line">    next: [<span class="number">26</span>]*Trie&#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, word := <span class="keyword">range</span> dictionary &#123;</span><br><span class="line">    root.insert(word)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//定义dp数组</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="comment">//普通情况，每一个字符都没有匹配，依次 +1</span></span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] +  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    curNode := root</span><br><span class="line">        <span class="comment">//倒序查找，从跟节点存在的字符向前查</span></span><br><span class="line">    <span class="keyword">for</span> j := i; j &gt;= <span class="number">1</span>; j-- &#123;</span><br><span class="line">      idx := <span class="keyword">int</span>(sentence[j - <span class="number">1</span>] - <span class="string">'a'</span>)</span><br><span class="line">      <span class="comment">//直到找到根节点的字符才开始向下查</span></span><br><span class="line">      <span class="keyword">if</span> curNode.next[idx] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> curNode.next[idx].isEnd &#123;</span><br><span class="line">                <span class="comment">//取最小值</span></span><br><span class="line">        dp[i] = min(dp[i], dp[j<span class="number">-1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> dp[i] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      curNode = curNode.next[idx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre class=&quot;mermaid&quot;&gt;graph TB
    A((.))
    B((.))
    C((.))
    D((.))
    E((.))
    F((.))
    G((.))
    H((.))
    I((.))
    J((.))

    A--t--&gt;B
    B--e--&gt;C
    C--s--&gt;D
    D--t--&gt;E
    B--r--&gt;F
    F--e--&gt;G
    G--e--&gt;H
    F--i--&gt;I
    I--e--&gt;J&lt;/pre&gt;

&lt;p&gt;字典树，也叫前缀树。典型应用是用于统计和排序大量字符串、搜素引擎输入关键词提示可能的选项。&lt;/p&gt;
&lt;p&gt;它能最大限度的减少无谓的字符串比较。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="字典树" scheme="//sunxingboo.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="树" scheme="//sunxingboo.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>etcd简单服务搭建方式记录</title>
    <link href="2020/07/08/etcd-build/"/>
    <id>2020/07/08/etcd-build/</id>
    <published>2020-07-07T16:00:00.000Z</published>
    <updated>2021-07-09T10:19:04.979Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下 etcd 搭建命令</p><a id="more"></a><p>启动三个节点</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 2379:2379 -p 2380:2380 \</span><br><span class="line">-<span class="ruby">-restart=always \</span></span><br><span class="line"><span class="ruby">--net etcdnet \</span></span><br><span class="line"><span class="ruby">--ip <span class="number">192.167</span>.<span class="number">0</span>.<span class="number">168</span> \</span></span><br><span class="line"><span class="ruby">--name etcd<span class="number">0</span> quay.io/coreos/etcd /usr/local/bin/etcd \</span></span><br><span class="line"><span class="ruby">--name autumn-client<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">-advertise-client-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.168:2379 \</span></span></span><br><span class="line"><span class="ruby">-listen-client-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2379 \</span></span></span><br><span class="line"><span class="ruby">-initial-advertise-peer-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.168:2380 \</span></span></span><br><span class="line"><span class="ruby">-listen-peer-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2380 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-token etcd-cluster \</span></span><br><span class="line"><span class="ruby">-initial-cluster autumn-client<span class="number">0</span>=<span class="symbol">http:</span>/<span class="regexp">/192.167.0.168:2380,autumn-client1=http:/</span><span class="regexp">/192.167.0.170:2480,autumn-client2=http:/</span><span class="regexp">/192.167.0.172:2580 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-state new</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">sudo docker run -d -p <span class="number">2479</span><span class="symbol">:</span><span class="number">2479</span> -p <span class="number">2480</span><span class="symbol">:</span><span class="number">2480</span> \</span></span><br><span class="line"><span class="ruby">--restart=always \</span></span><br><span class="line"><span class="ruby">--net etcdnet \</span></span><br><span class="line"><span class="ruby">--ip <span class="number">192.167</span>.<span class="number">0</span>.<span class="number">170</span> \</span></span><br><span class="line"><span class="ruby">--name etcd1 quay.io/coreos/etcd /usr/local/bin/etcd \</span></span><br><span class="line"><span class="ruby">--name autumn-client1 \</span></span><br><span class="line"><span class="ruby">-advertise-client-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.170:2479 \</span></span></span><br><span class="line"><span class="ruby">-listen-client-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2479 \</span></span></span><br><span class="line"><span class="ruby">-initial-advertise-peer-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.170:2480 \</span></span></span><br><span class="line"><span class="ruby">-listen-peer-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2480 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-token etcd-cluster \</span></span><br><span class="line"><span class="ruby">-initial-cluster autumn-client<span class="number">0</span>=<span class="symbol">http:</span>/<span class="regexp">/192.167.0.168:2380,autumn-client1=http:/</span><span class="regexp">/192.167.0.170:2480,autumn-client2=http:/</span><span class="regexp">/192.167.0.172:2580 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-state new</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">sudo docker run -d -p <span class="number">2579</span><span class="symbol">:</span><span class="number">2579</span> -p <span class="number">2580</span><span class="symbol">:</span><span class="number">2580</span> \</span></span><br><span class="line"><span class="ruby">--restart=always \</span></span><br><span class="line"><span class="ruby">--net etcdnet \</span></span><br><span class="line"><span class="ruby">--ip <span class="number">192.167</span>.<span class="number">0</span>.<span class="number">172</span> \</span></span><br><span class="line"><span class="ruby">--name etcd2 quay.io/coreos/etcd /usr/local/bin/etcd \</span></span><br><span class="line"><span class="ruby">--name autumn-client2 \</span></span><br><span class="line"><span class="ruby">-advertise-client-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.172:2579 \</span></span></span><br><span class="line"><span class="ruby">-listen-client-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2579 \</span></span></span><br><span class="line"><span class="ruby">-initial-advertise-peer-urls <span class="symbol">http:</span>/<span class="regexp">/192.167.0.172:2580 \</span></span></span><br><span class="line"><span class="ruby">-listen-peer-urls <span class="symbol">http:</span>/<span class="regexp">/0.0.0.0:2580 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-token etcd-cluster \</span></span><br><span class="line"><span class="ruby">-initial-cluster autumn-client<span class="number">0</span>=<span class="symbol">http:</span>/<span class="regexp">/192.167.0.168:2380,autumn-client1=http:/</span><span class="regexp">/192.167.0.170:2480,autumn-client2=http:/</span><span class="regexp">/192.167.0.172:2580 \</span></span></span><br><span class="line"><span class="ruby">-initial-cluster-state new</span></span><br></pre></td></tr></table></figure><p>两种管理后台</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name etcd-browser <span class="string">\</span></span><br><span class="line">-p <span class="number">8000</span>:<span class="number">8000</span> <span class="string">\</span></span><br><span class="line">--net etcdnet <span class="string">\</span></span><br><span class="line">--env ETCD_HOST=<span class="number">192.167</span>.<span class="number">0.168</span> <span class="string">\</span></span><br><span class="line">--env ETCD_PORT=<span class="number">2379</span> <span class="string">\</span></span><br><span class="line">buddho/etcd-browser</span><br><span class="line"></span><br><span class="line">docker run -<span class="literal">it</span> -d --name etcdkeeper <span class="string">\</span></span><br><span class="line">-p <span class="number">8001</span>:<span class="number">8080</span> <span class="string">\</span></span><br><span class="line">--net etcdnet <span class="string">\</span></span><br><span class="line">--env ETCDCTL_API=<span class="number">3</span> <span class="string">\</span></span><br><span class="line">--env ETCD_ENDPOINTS=<span class="string">"http://192.167.0.168:2379,http://192.167.0.170:2479,http://192.167.0.172:2579"</span> <span class="string">\</span></span><br><span class="line">deltaprojects/etcdkeeper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下 etcd 搭建命令&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="etcd" scheme="//sunxingboo.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>Golang多平台交叉编译</title>
    <link href="2020/07/07/go-build/"/>
    <id>2020/07/07/go-build/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2021-07-09T10:20:50.056Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 下编译 Linux 和 Windows 64位可执行程序</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGO_ENABLED</span>=0 <span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=amd64 go build main.go</span><br><span class="line"><span class="attribute">CGO_ENABLED</span>=0 <span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 go build main.go</span><br></pre></td></tr></table></figure><p>Linux 下编译 Mac 和 Windows 64位可执行程序</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGO_ENABLED</span>=0 <span class="attribute">GOOS</span>=darwin <span class="attribute">GOARCH</span>=amd64 go build main.go</span><br><span class="line"><span class="attribute">CGO_ENABLED</span>=0 <span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 go build main.go</span><br></pre></td></tr></table></figure><p>Windows 下编译 Mac 和 Linux 64位可执行程序</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> <span class="attribute">CGO_ENABLED</span>=0</span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">GOOS</span>=darwin</span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">GOARCH</span>=amd64</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">CGO_ENABLED</span>=0</span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">GOOS</span>=linux</span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">GOARCH</span>=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH：目标平台的体系架构（386、amd64、arm）<br>交叉编译不支持 CGO 所以要禁用它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac 下编译 Linux 和 Windows 64位可执行程序&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
    
      <category term="Golang" scheme="//sunxingboo.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历方式</title>
    <link href="2020/07/03/tree-traversal/"/>
    <id>2020/07/03/tree-traversal/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2021-07-09T10:31:41.397Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">graph TB    A((1))    B((2))    C((3))    D((4))    E((5))    F((6))    G((7))    A---B    A---C    B---D    B---E    C---F    C---G</pre><p>二叉树的遍历可以分为深度优先遍历和广度优先遍历两种</p><p>深度优先遍历也就是常说的前序、中序、后序遍历，可以通过递归和栈两种方式来实现</p><p>广度优先遍历就是按层次顺序遍历，可以通过队列来实现</p><p>上图四种遍历方式的结果依次为</p><p><strong>前序遍历：</strong>1， 2，4，5，3，6，7</p><p><strong>中序遍历：</strong>4、2， 5，1，6，7，3</p><p><strong>后序遍历：</strong>4， 5、2，6，7，3，1</p><p><strong>广度优先遍历：</strong>1， 2，4，5，3，6，7</p><a id="more"></a><h2 id="树结构定义"><a href="#树结构定义" class="headerlink" title="树结构定义"></a>树结构定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data  <span class="keyword">int</span></span><br><span class="line">  Left  *Node</span><br><span class="line">  Right *Node</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Print(n.Data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><div align="left"><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/142832f6-6acf-431e-9c1a-726768b5a96f.png" width="400" alt="深度优先"/></div><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">PreOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//先给出递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前序的顺序：当前节点-&gt;左子树-&gt;右子树</span></span><br><span class="line">  n.Print()</span><br><span class="line">  <span class="keyword">if</span> n.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Left.PreOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Right.PreOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">InOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//先给出递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中序的顺序：左子树-&gt;当前节点-&gt;右子树</span></span><br><span class="line">  <span class="keyword">if</span> n.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Left.MiddleOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  n.Print()</span><br><span class="line">  <span class="keyword">if</span> n.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Right.MiddleOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">PostOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//先给出递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后序的顺序：左子树-&gt;右子树-&gt;当前节点</span></span><br><span class="line">  <span class="keyword">if</span> n.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Left.PostOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    n.Right.PostOrder()</span><br><span class="line">  &#125;</span><br><span class="line">  n.Print()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>递归实现比较直观，层数过多时对性能影响较大</p><p>出了递归还可以通过栈结构来辅助实现迭代遍历，但相较于递归方式就不那么容易理解</p><p>简单的实现了一个栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  size     <span class="keyword">int</span></span><br><span class="line">  capacity <span class="keyword">int</span></span><br><span class="line">  data     []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">Stack</span></span> &#123;</span><br><span class="line">  arr := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, size)</span><br><span class="line">  <span class="keyword">return</span> &amp;Stack&#123;</span><br><span class="line">    capacity: <span class="built_in">cap</span>(arr),</span><br><span class="line">    data:     arr,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  s.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s.size+<span class="number">1</span> &gt; s.capacity &#123;</span><br><span class="line">    newArray := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, s.capacity*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.size; i++ &#123;</span><br><span class="line">      newArray[i] = s.data[i]</span><br><span class="line">    &#125;</span><br><span class="line">    s.data = newArray</span><br><span class="line">  &#125;</span><br><span class="line">  s.data[s.size] = e</span><br><span class="line">  s.size += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  s.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">  <span class="keyword">if</span> s.size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  top := s.data[s.size<span class="number">-1</span>]</span><br><span class="line">  s.size -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.size &lt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取栈元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">PreOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  currNode := n</span><br><span class="line">  s := stack.New(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">//思考一下整体过程：从根节点开始入栈-&gt;紧接着出栈-&gt;打印当前节点-&gt;右节点入栈，左节点入栈-&gt;紧接着左节点出栈</span></span><br><span class="line">    <span class="comment">//循环这个过程</span></span><br><span class="line">  <span class="keyword">for</span> currNode != <span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">    <span class="keyword">if</span> currNode != <span class="literal">nil</span> &#123;</span><br><span class="line">      currNode.Print()</span><br><span class="line">      <span class="comment">//考虑出栈时的顺序，因此入栈时先右后左入栈</span></span><br><span class="line">      s.Push(currNode.Right)</span><br><span class="line">      s.Push(currNode.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !s.IsEmpty() &#123;</span><br><span class="line">      currNode = s.Pop().(*Node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">InOrder</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  currNode := n</span><br><span class="line">  s := stack.New(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">//思考整体过程：中序，所以要沿着左子树先入栈</span></span><br><span class="line">    <span class="comment">//出栈时候的动作为：打印当前节点-&gt;切换到右子树，因为出栈时的节点必然是沿着左子树到大的叶子节点，这是好它的左右节点为nil</span></span><br><span class="line">    <span class="comment">//切换到它的右节点也为nil，所以开始出栈第二个节点，也就是叶子节点的父节点，同样执行打印，切换到右节点，这样就实现了中序</span></span><br><span class="line">  <span class="keyword">for</span> currNode != <span class="literal">nil</span> || !s.IsEmpty() &#123;</span><br><span class="line">    <span class="keyword">for</span> currNode != <span class="literal">nil</span> &#123;</span><br><span class="line">      s.Push(currNode)</span><br><span class="line">      currNode = currNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !s.IsEmpty() &#123;</span><br><span class="line">      currNode = s.Pop().(*Node)</span><br><span class="line">      currNode.Print()</span><br><span class="line">      currNode = currNode.Right<span class="comment">//切换到右子树，右子树如果有它的左子树，依然沿着左子树一路向下入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TreeNode)</span> <span class="title">PostOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> tn == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    currNode = tn</span><br><span class="line">    preNode *TreeNode</span><br><span class="line">    stack = New(<span class="number">5</span>)</span><br><span class="line">  )</span><br><span class="line">    <span class="comment">//思考整体过程：后序也是要先沿着左子树一路向下的到左叶子节点入栈</span></span><br><span class="line">    <span class="comment">//第一个出栈的也就是最左侧的叶子节点，之后向上出栈的也同样都是左节点，所以不需要判断left</span></span><br><span class="line">    <span class="comment">//因为后序是最后打印当前节点，所以我们需要一个辅助变量preNode来记录上一个遍历到的节点，如果它是当前节点的右子节点，就表明后序遍历完成，可以打印当前节点，否则就将currNode切换到它的Right上</span></span><br><span class="line">  <span class="keyword">for</span> currNode != <span class="literal">nil</span> || !stack.IsEmpty() &#123;</span><br><span class="line">    <span class="keyword">for</span> currNode != <span class="literal">nil</span> &#123;</span><br><span class="line">      stack.Push(currNode)</span><br><span class="line">      currNode = currNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    currNode = stack.Pop().(*TreeNode)</span><br><span class="line">    <span class="keyword">if</span> currNode.Right == <span class="literal">nil</span> || currNode.Right == preNode &#123;</span><br><span class="line">      currNode.Print()</span><br><span class="line">      preNode = currNode</span><br><span class="line">      currNode = <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currNode = currNode.Right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><div align="left"><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/860d03f0-4b1f-4668-acdb-25c04247460e.png" width="400" alt="广度优先"/></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">BreadthFirstSearch</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  nodes := []*Node&#123;n&#125;<span class="comment">//根节点入队</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    curNode := nodes[<span class="number">0</span>]</span><br><span class="line">    curNode.Print()</span><br><span class="line">    nodes = nodes[<span class="number">1</span>:]<span class="comment">//出队</span></span><br><span class="line">    <span class="comment">//先左后右入队</span></span><br><span class="line">    <span class="keyword">if</span> curNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">      nodes = <span class="built_in">append</span>(nodes, curNode.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> curNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">      nodes = <span class="built_in">append</span>(nodes, curNode.Right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre class=&quot;mermaid&quot;&gt;graph TB
    A((1))
    B((2))
    C((3))
    D((4))
    E((5))
    F((6))
    G((7))

    A---B
    A---C
    B---D
    B---E
    C---F
    C---G&lt;/pre&gt;

&lt;p&gt;二叉树的遍历可以分为深度优先遍历和广度优先遍历两种&lt;/p&gt;
&lt;p&gt;深度优先遍历也就是常说的前序、中序、后序遍历，可以通过递归和栈两种方式来实现&lt;/p&gt;
&lt;p&gt;广度优先遍历就是按层次顺序遍历，可以通过队列来实现&lt;/p&gt;
&lt;p&gt;上图四种遍历方式的结果依次为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序遍历：&lt;/strong&gt;1， 2，4，5，3，6，7&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历：&lt;/strong&gt;4、2， 5，1，6，7，3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历：&lt;/strong&gt;4， 5、2，6，7，3，1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广度优先遍历：&lt;/strong&gt;1， 2，4，5，3，6，7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="//sunxingboo.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>docker启动mysql8.0服务遇到的问题记录</title>
    <link href="2020/05/20/docker-mysql8/"/>
    <id>2020/05/20/docker-mysql8/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2021-07-09T10:16:55.321Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/docker.jpg" alt=""></p><a id="more"></a><p>启动容器</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">3306</span>:<span class="number">3306</span> --name mysql-server \</span><br><span class="line">-v /data/mysql/<span class="symbol">conf:</span>/etc/mysql \</span><br><span class="line">-v /data/mysql/<span class="symbol">logs:</span>/var/log/mysql \</span><br><span class="line">-v /data/mysql/<span class="symbol">data:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> \</span></span><br><span class="line">-v  /data/mysql/mysql-<span class="symbol">files:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span>-<span class="title">files</span> \</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD= \</span><br><span class="line">-d mysql</span><br></pre></td></tr></table></figure><p>此时可能从外部无法连接容器内的mysql</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter<span class="built_in"> user </span><span class="string">'root'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure><p>可能遇到如下问题或其他错误：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span><span class="built_in"> user </span><span class="string">'root'</span>@<span class="string">'localhost'</span> (using password: <span class="literal">YES</span>)</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update<span class="built_in"> user </span><span class="builtin-name">set</span> authentication_string = <span class="string">'root'</span> where<span class="built_in"> user </span>= <span class="string">'root'</span> <span class="keyword">and</span> host = <span class="string">'%'</span>;</span><br><span class="line">update<span class="built_in"> user </span><span class="builtin-name">set</span> authentication_string = <span class="string">'root'</span> where<span class="built_in"> user </span>= <span class="string">'root'</span> <span class="keyword">and</span> host = <span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>使用<code>sequel pro</code>进行连接时，报如下错误：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL <span class="string">said:</span> Authentication plugin <span class="string">'caching_sha2_password'</span> cannot be <span class="string">loaded:</span> dlopen(<span class="regexp">/usr/</span>local<span class="regexp">/mysql/</span>lib<span class="regexp">/plugin/</span>caching_sha2_password.so, <span class="number">2</span>): image not found</span><br></pre></td></tr></table></figure><p>原因</p><p>mysql8之前的版本中加密规则是<code>mysql_native_password</code>，而mysql8之后，加密规则是<code>caching_sha2_password</code>，而数据库客户端无对应的驱动。</p><p>解决方法</p><p>登录到容器中，修改加密规则并更新用户密码，刷新权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;   #修改加密规则 </span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;   #更新一下用户的密码</span><br><span class="line">FLUSH PRIVILEGES;   #刷新权限</span><br></pre></td></tr></table></figure><p>此时再次尝试连接，成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/docker.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="//sunxingboo.github.io/tags/docker/"/>
    
      <category term="mysql" scheme="//sunxingboo.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go mod的使用</title>
    <link href="2020/04/19/go-mod/"/>
    <id>2020/04/19/go-mod/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2021-07-09T10:19:29.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/go-mod.png" alt=""></p><a id="more"></a><p>在 2019 年刚接触 Go 的时候，项目中包的引入是采用<code>go get</code>下载到<code>src</code>目录的方式。此时依赖包与项目处于同级目录。</p><p>今年来到新公司，主要从事 Go 的开发，项目的包管理采用 <code>go mod</code>的方式，也是比较新的版本才提供的官方包管理机制，大致做一下使用方法记录。</p><p>在项目根目录创建<code>go.mod</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init [模块名]</span><br></pre></td></tr></table></figure><p><code>require</code>引入依赖包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module blockchain</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">  github.com/boltdb/bolt v1<span class="number">.3</span><span class="number">.2</span><span class="number">-0.20180302180052</span>-fd01fc79c553</span><br><span class="line">  golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200413165638</span><span class="number">-669</span>c56c373c4 <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>后面可以标明包的版本，可以是标签或者分支名。</p><p>执行<code>go mod tidy</code>后会拉取依赖包或清除不再使用的依赖包，存放的目录在<code>$GOPATH/pkg/mod/</code>，同一个包可以存在多个版本。</p><p>如果希望将项目的依赖包纳入版本控制，可以执行<code>go mod vendor</code>，在项目根目录下生成<code>vendor</code>目录并存放依赖包。</p><p>如果后续需要替换依赖包，可以使用<code>replace</code>关键字：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module blockchain</span><br><span class="line">go <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">  github.com/boltdb/bolt v1<span class="number">.3</span><span class="number">.2</span><span class="number">-0.20180302180052</span>-fd01fc79c553</span><br><span class="line">  golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200413165638</span><span class="number">-669</span>c56c373c4 <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line">replace github.com/boltdb/bolt =&gt; github.com/AAA/BBB</span><br></pre></td></tr></table></figure><p>使用 Goland 时，需要在偏好设置中开启 Go Module 设置，否则程序虽然可以正常运行，但是 IDE 中导入的包依然会显示为错误的红色：</p><p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/contentImg/%E6%88%AA%E5%B1%8F2020-04-19%E4%B8%8B%E5%8D%886.30.46.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/go-mod.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Go" scheme="//sunxingboo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>golang的异常处理</title>
    <link href="2020/04/05/go-panic/"/>
    <id>2020/04/05/go-panic/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2021-07-09T10:20:26.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/golang.jpg" alt=""></p><a id="more"></a><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The panic built-in function stops normal execution of the current</span></span><br><span class="line"><span class="comment">// goroutine. When a function F calls panic, normal execution of F stops</span></span><br><span class="line"><span class="comment">// immediately. Any functions whose execution was deferred by F are run in</span></span><br><span class="line"><span class="comment">// the usual way, and then F returns to its caller. To the caller G, the</span></span><br><span class="line"><span class="comment">// invocation of F then behaves like a call to panic, terminating G's</span></span><br><span class="line"><span class="comment">// execution and running any deferred functions. This continues until all</span></span><br><span class="line"><span class="comment">// functions in the executing goroutine have stopped, in reverse order. At</span></span><br><span class="line"><span class="comment">// that point, the program is terminated with a non-zero exit code. This</span></span><br><span class="line"><span class="comment">// termination sequence is called panicking and can be controlled by the</span></span><br><span class="line"><span class="comment">// built-in function recover.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>内建函数<code>panic</code>的作用是停止当前协程的正常执行。</p><ul><li><p>当在函数<code>F</code>内调用<code>panic</code>时，<code>F</code>的正常执行立即停止</p></li><li><p>执行<code>defer</code>声明的动作，然后<code>F</code>返回其调用者（假设调用者为<code>G</code>函数）</p></li><li>此时在<code>G</code>中，对<code>F</code>的调用就如同调用<code>panic</code>，继而终止<code>G</code>的执行并且开始指定<code>defer</code></li><li>接下来继续向上返回，直到协程中的所有函数都被终止执行</li><li>程序以一个非 0 的状态码退出</li></ul><p>这个终止流被称为<code>panicking</code>，可以通过内建函数<code>recover</code>来进行控制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"main func start"</span>)</span><br><span class="line">  f1()</span><br><span class="line">  fmt.Println(<span class="string">"main func end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  fmt.Println(<span class="string">"f1 func start"</span>)</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"f1 func panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main func start</span></span><br><span class="line"><span class="comment">//f1 func start</span></span><br><span class="line"><span class="comment">//panic: f1 func panic</span></span><br></pre></td></tr></table></figure><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The recover built-in function allows a program to manage behavior of a</span></span><br><span class="line"><span class="comment">// panicking goroutine. Executing a call to recover inside a deferred</span></span><br><span class="line"><span class="comment">// function (but not any function called by it) stops the panicking sequence</span></span><br><span class="line"><span class="comment">// by restoring normal execution and retrieves the error value passed to the</span></span><br><span class="line"><span class="comment">// call of panic. If recover is called outside the deferred function it will</span></span><br><span class="line"><span class="comment">// not stop a panicking sequence. In this case, or when the goroutine is not</span></span><br><span class="line"><span class="comment">// panicking, or if the argument supplied to panic was nil, recover returns</span></span><br><span class="line"><span class="comment">// nil. Thus the return value from recover reports whether the goroutine is</span></span><br><span class="line"><span class="comment">// panicking.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>内建函数<code>recover</code>允许程序管理一个发生了<code>panicking</code>的协程的行为。</p><p>在<code>defer</code>函数（而不是其调用的函数）中调用<code>recover</code>函数，通过恢复正常的执行来停止<code>panicking</code>序列，并检索传递给<code>panic</code>的错误值。</p><p>如果在<code>defer</code>之外调用<code>recover</code>则不会停止<code>panicking</code>序列。</p><p>当在协程内没有发生<code>panic</code>，或者传递给<code>panic</code>参数为<code>nil</code>，则<code>recover</code>的返回值为<code>nil</code>。</p><p>因此<code>recover</code>的返回值就表明了协程是否发生了<code>panic</code>。</p><p>捕获<code>panic</code>并恢复程序的正常执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"main func start"</span>)</span><br><span class="line">  f1()</span><br><span class="line">  fmt.Println(<span class="string">"main func end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  fmt.Println(<span class="string">"f1 func start"</span>)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"f1 catch err: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//panic("f1 func panic")</span></span><br><span class="line">  f2()</span><br><span class="line">  fmt.Println(<span class="string">"f1 func end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  fmt.Println(<span class="string">"f2 func start"</span>)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"catch err: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"f2 func panic"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"f2 func end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main func start</span></span><br><span class="line"><span class="comment">//f1 func start</span></span><br><span class="line"><span class="comment">//f2 func start</span></span><br><span class="line"><span class="comment">//catch err:  f2 func panic</span></span><br><span class="line"><span class="comment">//f1 func end</span></span><br><span class="line"><span class="comment">//main func end</span></span><br></pre></td></tr></table></figure><p>捕捉到当前层的<code>panic</code>，恢复上一层的正常执行。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>defer</code>的三个特性：</p><ul><li>声明<code>defer</code>时实时解析参数</li><li>多个<code>defer</code>的执行顺序为先进后出</li><li>可以读取并改变有名返回参数的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"i= "</span>, i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i= 1</span></span><br></pre></td></tr></table></figure><p>这里输出的结果为<code>i= 1</code>，因为声明<code>defer</code>时，后面的参数立即被解析，所以传入的<code>i</code>是 1，之后的增量不会被捕获到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"first defer"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"second defer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//second defer</span></span><br><span class="line"><span class="comment">//first defer</span></span><br></pre></td></tr></table></figure><p>先声明的<code>defer</code>后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f1())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11</span></span><br></pre></td></tr></table></figure><p><code>return</code>不是原子操作。</p><p>当返回值有名时，返回值相当于引用赋值，所以可以被<code>defer</code>修改。而匿名返回值相当于拷贝赋值，不会被修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f1())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i = <span class="number">7</span></span><br><span class="line">    &#125;()</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/golang.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Go" scheme="//sunxingboo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang中new()与make()的作用与区别</title>
    <link href="2020/04/04/go-new-and-make/"/>
    <id>2020/04/04/go-new-and-make/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2021-07-09T10:20:06.258Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/golang.jpg" alt="golang"></p><a id="more"></a><p>先看一下源码中这两个函数的说明</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new built-in function allocates memory. The first argument is a type,</span></span><br><span class="line"><span class="comment">// not a value, and the value returned is a pointer to a newly</span></span><br><span class="line"><span class="comment">// allocated zero value of that type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>内置函数<code>new</code>分配内存。</p><p>第一个参数是一个类型，而不是值，这个函数会分配一个这个类型的零值，并返回这个零值的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> TestNew <span class="keyword">struct</span> &#123;</span><br><span class="line">  str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  t1 := <span class="built_in">new</span>(TestNew)</span><br><span class="line">  t2 := &amp;TestNew&#123;&#125;</span><br><span class="line">  fmt.Println(reflect.TypeOf(t1), reflect.TypeOf(t2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *main.TestNew *main.TestNew</span></span><br></pre></td></tr></table></figure><p>这两种创建变量的方式作用是相同的。</p><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The make built-in function allocates and initializes an object of type</span></span><br><span class="line"><span class="comment">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></span><br><span class="line"><span class="comment">// value. Unlike new, make's return type is the same as the type of its</span></span><br><span class="line"><span class="comment">// argument, not a pointer to it. The specification of the result depends on</span></span><br><span class="line"><span class="comment">// the type:</span></span><br><span class="line"><span class="comment">//Slice: The size specifies the length. The capacity of the slice is</span></span><br><span class="line"><span class="comment">//equal to its length. A second integer argument may be provided to</span></span><br><span class="line"><span class="comment">//specify a different capacity; it must be no smaller than the</span></span><br><span class="line"><span class="comment">//length. For example, make([]int, 0, 10) allocates an underlying array</span></span><br><span class="line"><span class="comment">//of size 10 and returns a slice of length 0 and capacity 10 that is</span></span><br><span class="line"><span class="comment">//backed by this underlying array.</span></span><br><span class="line"><span class="comment">//Map: An empty map is allocated with enough space to hold the</span></span><br><span class="line"><span class="comment">//specified number of elements. The size may be omitted, in which case</span></span><br><span class="line"><span class="comment">//a small starting size is allocated.</span></span><br><span class="line"><span class="comment">//Channel: The channel's buffer is initialized with the specified</span></span><br><span class="line"><span class="comment">//buffer capacity. If zero, or the size is omitted, the channel is</span></span><br><span class="line"><span class="comment">//unbuffered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>内置函数<code>make</code>分配并初始化一个<code>slice</code>、<code>map</code>或者<code>chan</code>对象（只支持这三种）。</p><p>与<code>new</code>函数相似，第一个参数是一个类型，而不是值。</p><p>与<code>new</code>不同的是，<code>make</code>函数的返回值的类型与它的参数指定的类型相同，而不是指向这个类型的指针。</p><p>其返回值依赖于具体传入的类型：</p><ul><li><code>slice</code>：<code>size</code>指定切片的长度。第二个<code>int</code>参数可以指定切片长度。第三个参数指定切片容量，这个值必须不小于长度。</li><li><code>map</code>：根据<code>size</code>指定的数量来分配足够的空间容纳元素的空<code>map</code>。忽略<code>size</code>参数则会默认分配一个较小的初始长度的<code>map</code>。</li><li><code>channel</code>：通道的缓冲区通过指定的缓冲区容量来初始化。如果<code>size</code>参数值为 0 或者被省略，则这个通道是没有缓冲区的（简单举例就是写入一个数据就会进入阻塞状态）。</li></ul><p>初始化<code>map</code>和<code>channel</code>时，可以忽略<code>size</code>参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>初始化<code>slice</code>时必须指定长度，容量可以忽略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>)       <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)    <span class="comment">//长度和容量均为2</span></span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//长度为2，容量为3</span></span><br></pre></td></tr></table></figure><p>初始化<code>channel</code>时指定缓冲区容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>对于<code>slice</code>和<code>channel</code>均可以使用内置函数<code>len</code>获取长度，使用<code>cap</code>获取容量，而对于<code>map</code>不能使用<code>cap</code>函数。</p><p><code>map</code>是没有大小或长度的限制的。比如初始化一个指定容量的<code>map</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">m[<span class="string">"t1"</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">"t2"</span>] = <span class="number">2</span> <span class="comment">//此时已经超出指定的容量1，会动态的调整大小</span></span><br></pre></td></tr></table></figure><p>频繁的调整会影响性能，因此当定义一个元素数量的增长趋势比较大的<code>map</code>时。应该大致的预定义一个容量，而不是让它频繁的触发容量调整。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-static-resources.oss-cn-beijing.aliyuncs.com/blogImg/golang.jpg&quot; alt=&quot;golang&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Go" scheme="//sunxingboo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="2020/03/24/http-status-code/"/>
    <id>2020/03/24/http-status-code/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2021-07-09T10:23:39.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h2><p>以 1 开头的状态码代表请求已被接受，需要继续处理。</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>服务器已经接收到请求头，并且客户端应继续发送请求主体</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采<br>用不同的协议来完成这个请求。</td></tr><tr><td>102</td><td>Processing</td><td>请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。<br>该代码表示服务器已经收到并正在处理请求，但无响应可用。<br>这样可以防止客户端超时，并假设请求丢失</td></tr></tbody></table></div><a id="more"></a><h2 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h2><p>以 2 开头的状态码代表请求已被服务器接受并处理</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，请求所希望的响应头或数据体将随此响应返回</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器是一个转换代理服务器，以<code>200 OK</code>状态码为起源，但回应了原始响应的修改版本。</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，没有返回任何内容</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图</td></tr><tr><td>206</td><td>Partial Conten</td><td>服务器已经成功处理了部分GET请求</td></tr><tr><td>207</td><td>Multi-Status</td><td>代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码</td></tr><tr><td>208</td><td>Already Reported</td><td>DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含</td></tr><tr><td>226</td><td>IM Used</td><td>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示</td></tr></tbody></table></div><h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><p>以 3 为开头的状态码代表重定向</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>代表请求的资源有多个可选择的信息，返回一个列表用户或浏览器自行选择一个进行重定向</td></tr></tbody></table></div><p>有些浏览器实现 301 时没有按照协议（可以修改请求方法），因此定义了 308</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久重定向，后续请求应该使用响应的地址<br>理论上除了GET与HEAD之外的请求方法，浏览器应禁止自动重定向<br>但是有的浏览器的实现中会改变请求方法（原请求为POST，重定向请求为GET）</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>与301基本相同，区别在于不允许修改请求方法</td></tr></tbody></table></div><p>类似 301 的实现一样，有些浏览器实现 302 没有按照协议，由 303 和 307 进行限制。</p><p>但是实际实现中还是以 302 和 307 为主</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>302</td><td>Found</td><td>临时重定向，后续请求应该使用原来的URI<br>并且除非设置Cache-contrl和expries等头，否则不进行缓存<br>理论上除了GET与HEAD之外的请求方法，浏览器应禁止自动重定向<br/>但是有的浏览器的实现中会改变请求方法（原请求为POST，重定向请求为GET）</td></tr><tr><td>303</td><td>See Other</td><td>与302基本相同，允许修改请求方法（原为POST，重定向为GET）</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>与302基本相同，不允许修改请求方法（原为POST，重定向仍为POST）</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>304</td><td>Not Modified</td><td>资源未变更，不需要给客户端响应数据，客户端可以使用缓存</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>305</td><td>Use Proxy</td><td>请求的资源必须使用指定的代理才能进行访问<br>Location中给出代理的URI信息，客户端重复发送一个请求，向代理请求资源</td></tr><tr><td>306</td><td>Switch Proxy</td><td>后续请求使用指定的代理</td></tr></tbody></table></div><h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>明显的请求错误，比如请求语法错误，服务器看不懂不知道怎么处理</td></tr><tr><td>401</td><td>Unauthorized</td><td>未认证，需要登录</td></tr><tr><td>402</td><td>Payment Required</td><td>预留的，很少用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求，但是拒绝执行</td></tr><tr><td>404</td><td>Not Found</td><td>未找到资源</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求使用的方法不能被用于请求该资源</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件<br>因而无法生成响应实体，该请求不可接受</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>类似401，客户端必须在代理服务器上进行身份验证</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时，客户端没有在服务器预备等待的时间内完成一个请求的发送</td></tr><tr><td>409</td><td>Conflict</td><td>表示因为请求存在冲突无法处理该请求<br>例如多个同步更新之间的编辑冲突。</td></tr><tr><td>410</td><td>Gone</td><td>表示所请求的资源不再可用，将不再可用。<br>当资源被有意地删除并且资源应被清除时，应该使用这个。<br>在收到410状态码后，用户应停止再次请求资源。<br>但大多数服务端不会使用此状态码，而是直接使用404状态码。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义Content-Length头的情况下接受请求</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。<br>这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）<br>中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>表示服务器拒绝处理当前请求，<br>因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。<br>此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</td></tr><tr><td>414</td><td>Request-URI Too Long</td><td>如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，<br>以告知客户端可以在多少时间以后重新尝试。<br>表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，<br>请求中提交的<a href="https://zh.wikipedia.org/wiki/互联网媒体类型" target="_blank" rel="noopener">互联网媒体类型</a>并不是服务器中所支持的格式，<br>因此请求被拒绝。例如，客户端将图像上传格式为svg，<br>但服务器要求图像使用上传格式为jpg。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>客户端已经要求文件的一部分，但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头Expect中指定的预期内容无法被服务器满足，<br>或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，<br>Expect的内容无法被满足。</td></tr><tr><td>418</td><td>I’m a teapot</td><td>本操作码是在1998年作为<a href="https://zh.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IETF</a>的传统<a href="https://zh.wikipedia.org/wiki/惡搞RFC" target="_blank" rel="noopener">愚人节笑话</a>,<br> 在RFC 2324<a href="https://zh.wikipedia.org/wiki/超文本咖啡壶控制协议" target="_blank" rel="noopener">超文本咖啡壶控制协议</a>‘中定义的，<br>并不需要在真实的HTTP服务器中定义。<br>当一个控制茶壶的<a href="https://zh.wikipedia.org/wiki/HTCPCP" target="_blank" rel="noopener">HTCPCP</a>收到BREW或POST指令要求其煮咖啡时应当回传此错误。</td></tr><tr><td>421</td><td>Misdirected Request</td><td>该请求针对的是无法产生响应的服务器（例如因为连接重用）</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>请求格式正确，但是由于含有<a href="https://zh.wikipedia.org/wiki/语义" target="_blank" rel="noopener">语义</a>错误，无法响应</td></tr><tr><td>423</td><td>Locked</td><td>当前资源被锁定</td></tr><tr><td>424</td><td>Failed Dependency</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH</td></tr><tr><td>425</td><td>Too Early</td><td>服务器拒绝处理在Early Data中的请求，以规避可能的<a href="https://zh.wikipedia.org/wiki/重放攻击" target="_blank" rel="noopener">重放攻击</a></td></tr><tr><td>426</td><td>Upgrade Required</td><td>客户端应切换到<a href="https://zh.wikipedia.org/w/index.php?title=Upgrade头字段&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Upgrade头字段</a>中给出的不同协议，如<a href="https://zh.wikipedia.org/wiki/传输层安全" target="_blank" rel="noopener">TLS/1.0</a></td></tr><tr><td>428</td><td>Precondition Required</td><td>原服务器要求该请求满足一定条件。<br>这是为了防止“未更新”问题，即客户端读取（GET）一个资源的状态，<br>更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上<br>更改了该资源的状态，因此导致了冲突。</td></tr><tr><td>429</td><td>Too Many Requests</td><td>用户在给定的时间内发送了太多的请求。旨在用于<a href="https://zh.wikipedia.org/w/index.php?title=网络限速&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">网络限速</a>。</td></tr><tr><td>431</td><td>Request Header Fields Too Large</td><td>服务器不愿处理请求，因为一个或多个头字段过大</td></tr><tr><td>499</td><td>client has closed connection</td><td>代表客户端主动断开了链接<br>一般是服务端处理时间太长了，客户端等的不耐烦了就断开了<br>还有可能是有人故意发起攻击消耗服务端资源</td></tr><tr><td>451</td><td>Unavailable For Legal Reason</td><td>该访问因<a href="https://zh.wikipedia.org/wiki/法律" target="_blank" rel="noopener">法律</a>的要求而被拒绝</td></tr></tbody></table></div><h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><p>以 5 开头的状态码代表服务端的错误</p><p>实际工作中 500～504 比较常见</p><div class="table-container"><table><thead><tr><th>Code</th><th>Describe</th><th>Note</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>通常是源代码导致的错误</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需的某个功能<br>无法识别请求的方法、无法支持对任何资源的请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或代理服务器处理请求时，从上游服务器收到无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>临时维护或过载导致暂时不可用<br>这是临时性的<br>可以在相应头中通过Retry-After引导客户端重试</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或代理服务器处理请求时，未能及时从上游服务器收到响应<br>超时</td></tr><tr><td>505</td><td>Http Version Not Supported</td><td>服务器不支持或拒绝请求中使用的HTTP版本</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>代表服务器存在内部配置错误</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容</td></tr><tr><td>508</td><td>Loop Detected</td><td>服务器在处理请求时陷入死循环</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有被满</td></tr><tr><td>511</td><td>Network Authentication Required</td><td>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1XX&quot;&gt;&lt;a href=&quot;#1XX&quot; class=&quot;headerlink&quot; title=&quot;1XX&quot;&gt;&lt;/a&gt;1XX&lt;/h2&gt;&lt;p&gt;以 1 开头的状态码代表请求已被接受，需要继续处理。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Describe&lt;/th&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;服务器已经接收到请求头，并且客户端应继续发送请求主体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching Protocols&lt;/td&gt;
&lt;td&gt;服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采&lt;br&gt;用不同的协议来完成这个请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;Processing&lt;/td&gt;
&lt;td&gt;请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。&lt;br&gt;该代码表示服务器已经收到并正在处理请求，但无响应可用。&lt;br&gt;这样可以防止客户端超时，并假设请求丢失&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
    
      <category term="HTTP" scheme="//sunxingboo.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="2020/03/22/redis-replica/"/>
    <id>2020/03/22/redis-replica/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2021-07-09T10:27:52.733Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">graph TB    A[master]    B[slave]    C[slave]    D[slave]    E[slave]    F[slave]    A-->B    A-->C    A-->D    C-->E    D-->F</pre><p>单机的<code>Redis</code>容易发生单点故障，服务器负载较大时的处理性能也有很大局限。</p><p>因此<code>Redis</code>提供主从复制机制，可以提高发生灾难性问题时数据的安全性，也能分担服务器负载压力。</p><p>网络内只有一个<code>master</code>节点，多个<code>slave</code>节点，<code>master</code>节点有多个<code>slave</code>，一个<code>slave</code>只有一个<code>master</code>节点。如上图所示。</p><a id="more"></a><h2 id="相关命令与配置"><a href="#相关命令与配置" class="headerlink" title="相关命令与配置"></a>相关命令与配置</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>将当前<code>redis</code>服务器设置为指定<code>master</code>节点的<code>slave</code>节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof no one</span><br></pre></td></tr></table></figure><p>取消复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role</span><br></pre></td></tr></table></figure><p>查看节点角色</p><p><code>master</code>执行此命令返回 3 个元素的列表：</p><ul><li>字符串<code>master</code></li><li>主服务器的复制偏移量</li><li>记录所有下属<code>slave</code>节点的数组<ul><li><code>IP</code></li><li>端口号</li><li>复制偏移量（当与主服务器的复制偏移量一直时，主从数据才是同步的）</li></ul></li></ul><p><code>slave</code>执行此命令返回 5 个元素组成的列表：</p><ul><li>字符串<code>slave</code></li><li><code>master</code>的<code>IP</code></li><li><code>master</code>的端口号</li><li>目前与主服务器的链接状态<ul><li><code>none</code></li><li><code>connect</code></li><li><code>connecting</code></li><li><code>sync</code></li><li><code>connected</code></li><li><code>unkonwn</code></li></ul></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replica-read-only &lt; yes | no &gt;</span><br></pre></td></tr></table></figure><p>设置从<code>slave</code>节点的只读模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync &lt; yes | no &gt;</span><br></pre></td></tr></table></figure><p>默认为<code>no</code>，完整同步数据时，<code>master</code>节点创建<code>RDB</code>文件并传给<code>slave</code>。</p><p>如果设为<code>yes</code>，则<code>master</code>创建子进程并在其中创建当前数据的<code>RDB</code>数据并直接传给<code>slave</code>（不写入<code>master</code>节点的磁盘），但是在<code>slave</code>节点接受到<code>RDB</code>数据后依然需要写盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync-delay &lt;seconds&gt;</span><br></pre></td></tr></table></figure><p><code>repl-diskless-sync</code>选项开启后，可以用这个选项来配置传输延迟的秒数。</p><p>在这个等待时间内可能有多个<code>slave</code>连接上来，这样就可以一起传输，否则一旦传输开始，后链接上的<code>slave</code>只能等待。</p><p>禁用的话可以设置为 0。</p><h2 id="数据同步方式"><a href="#数据同步方式" class="headerlink" title="数据同步方式"></a>数据同步方式</h2><h3 id="完整同步"><a href="#完整同步" class="headerlink" title="完整同步"></a>完整同步</h3><p>当一个节点成为一个主节点的从节点之后，会进行一次完整的同步：</p><pre class="mermaid">graph TB    A[从节点清空原有数据]    B[主节点bgsave生成RDB文件  并且在这之后执行的命令写入缓冲区]    C[通过套接字将RDB传给从节点]    D[从节点载入RDB数据]    E[从节点上线运行]    F[主节点将缓冲区中的命令传给从节点]    G[从节点执行命令]    H[主从数据完成同步]    A-->B    B-->C    C-->D    D-->E    E-->F    F-->G    G-->H</pre><h3 id="在线更新"><a href="#在线更新" class="headerlink" title="在线更新"></a>在线更新</h3><p>主服务器有新的命令执行后，就会将命令发送给从服务器，从服务器执行成功后，完成数据的在线更新。</p><pre class="mermaid">sequenceDiagram     participant client    participant master    participant slave    client->>master: 命令    master->>master:执行命令    master->>slave: 将命令发送给slave    slave->>slave: 执行命令</pre><p>在<code>slave</code>节点执行了命令之后，数据完成同步。</p><p>但是可以看出，从<code>master</code>执行了命令，到<code>slave</code>执行完成命令这一段时间，数据存在短暂的不一致。</p><h3 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h3><p>当下线的节点重新上线时，与主服务器数据已不再一致，此时需要进行同步。</p><p>老的处理方法是进行一次完整同步，但如果这个从服务器只是短暂下线，那么数据的差异很小，进行完整同步就十分没有必要并且很耗费资源。</p><p>新的数据同步策略是：</p><pre class="mermaid">sequenceDiagram     participant client    participant master    participant queue    participant slave    slave->>slave: 下线    client->>master: 命令    master->>master: 执行命令    master->>queue: 将命令放入队列    slave->>slave: 重新上线    slave->>master: 复制请求    queue->>slave: 发送队列内的命令</pre><p>在<code>slave</code>重新上线后，<code>master</code>先查看<code>slave</code>下线期间执行的命令是否在队列内，如果在则将命令发送给<code>slave</code>，否则执行一次完整同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size &lt;size&gt;</span><br></pre></td></tr></table></figure><p>可以通过这个配置来设置<code>FIFO</code>队列的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre class=&quot;mermaid&quot;&gt;graph TB
    A[master]
    B[slave]
    C[slave]
    D[slave]
    E[slave]
    F[slave]

    A--&gt;B
    A--&gt;C
    A--&gt;D
    C--&gt;E
    D--&gt;F&lt;/pre&gt;

&lt;p&gt;单机的&lt;code&gt;Redis&lt;/code&gt;容易发生单点故障，服务器负载较大时的处理性能也有很大局限。&lt;/p&gt;
&lt;p&gt;因此&lt;code&gt;Redis&lt;/code&gt;提供主从复制机制，可以提高发生灾难性问题时数据的安全性，也能分担服务器负载压力。&lt;/p&gt;
&lt;p&gt;网络内只有一个&lt;code&gt;master&lt;/code&gt;节点，多个&lt;code&gt;slave&lt;/code&gt;节点，&lt;code&gt;master&lt;/code&gt;节点有多个&lt;code&gt;slave&lt;/code&gt;，一个&lt;code&gt;slave&lt;/code&gt;只有一个&lt;code&gt;master&lt;/code&gt;节点。如上图所示。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="//sunxingboo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据持久化</title>
    <link href="2020/03/22/redis-persistence/"/>
    <id>2020/03/22/redis-persistence/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2021-07-09T10:27:29.388Z</updated>
    
    <content type="html"><![CDATA[<p><code>Redis</code>的所有数据都在内存中，断电后将全部丢失。数据的持久化功能就是为了解决这一问题。</p><p><code>Redis</code>提供了<code>RDB</code>、<code>AOF</code>以及<code>RDB-AOF</code>混合模式。</p><a id="more"></a><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><code>RDB</code>全称为<code>Redis Database</code>，是<code>Redis</code>默认的持久化方案。这种方式是在某个触发点生成这一时刻的数据库的一个数据快照，存储为<code>.rdb</code>为后缀名的一个二进制文件。</p><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>可以在配置文件中进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">save 900 1<span class="comment"># 900秒内变更1次</span></span><br><span class="line">save 300 10<span class="comment"># 300秒内变更10次</span></span><br><span class="line">save 60 10000<span class="comment"># 60秒内变更10000次</span></span><br></pre></td></tr></table></figure><p>配置触发点，在<code>seconds</code>秒内发生了<code>changes</code>次数据变更时触发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error &lt; yes | no &gt;</span><br></pre></td></tr></table></figure><p>配置当后台写入失败时，<code>Redis</code>是否停止接受写入，默认为<code>yes</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rdbcompression</span> <span class="string">&lt;</span> <span class="literal">yes</span> <span class="string">|</span> <span class="literal">no</span> <span class="string">&gt;</span></span><br></pre></td></tr></table></figure><p>是否使用<code>LZF</code>方式压缩<code>RDB</code>文件。关闭这个配置可能在子进程中节约一些<code>CPU</code>，但是如果数据内有可压缩的键值时，<code>RDB</code>文件的会比较大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbchecksum &lt; yes | no &gt;</span><br></pre></td></tr></table></figure><p>从第五版<code>RDB</code>文件开始，在文件的结尾加入了一个<code>CRC64</code>校验和。防止文件损坏，但是要付出大约 10% 的性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>配置<code>RDB</code>文件名，默认为<code>dump.rdb</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &lt;path&gt;</span><br></pre></td></tr></table></figure><p>配置<code>RDB</code>文件目录，默认为<code>/var/lib/redis</code>。</p><h3 id="方式及其命令"><a href="#方式及其命令" class="headerlink" title="方式及其命令"></a>方式及其命令</h3><h4 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><p>执行<code>save</code>命令，<code>Redis</code>服务器进入阻塞状态，无法为其他客户端提供服务。<code>RDB</code>文件创建成功之后将旧文件替换掉。</p><h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure><p><code>bgsave</code>命令不会阻塞服务器，而是创建一个子进程，子进程执行<code>save</code>命令，创建成功后子进程退出并通知父进程新<code>RDB</code>文件已完成，<code>Redis</code>服务器进程将旧文件替换掉。</p><p>但是由于这一操作要创建子进程，所以父进程占用的内存越大，则创建子进程耗时越长，因此执行此命令时，仍然有可能因为创建子进程导致短暂的阻塞。</p><p>在配置文件中的<code>save</code>配置，服务器自动执行的就是<code>bgsave</code>命令。</p><h4 id="命令选择"><a href="#命令选择" class="headerlink" title="命令选择"></a>命令选择</h4><p>那么在手动执行时如何决定使用哪个方式呢？</p><p><code>save</code>在执行时会阻塞整个服务器，索引如果因为备份的同时为其他客户端提供服务，就应该使用<code>bgsave</code>。</p><p><code>save</code>执行时不需要创建子进程，在不需要提供服务时，可以使用<code>save</code>命令。</p><h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><p><code>save</code>命令是阻塞的方式，它的开始和结束是一个原子操作。所以这种方式在停机时丢失的是在最后一次成功执行<code>save</code>命令之后产生的所有数据。</p><p><code>bgsave</code>的开始和结束是异步的。所以这种采用这种方式，在停机时丢失的是最后一次成功执行<code>bgsave</code>命令的开始时间。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><ul><li><code>RDB</code>文件标识符</li><li>版本号</li><li>设备附加信息</li><li>数据</li><li><code>Lua</code>脚本缓存</li><li><code>EOF</code></li><li><code>CRC64</code>校验和</li></ul><h4 id="文件标识符"><a href="#文件标识符" class="headerlink" title="文件标识符"></a>文件标识符</h4><p>文件的开头部分，为<code>REDIS</code>这 5 个字符，在载入<code>RDB</code>文件的时候会通过这个标识符快速判断是否为<code>RDB</code>文件。</p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>一个长度为 4 个字符的字符串格式的数字，如<code>0009</code>，第 9 版。文件的读取版本向下兼容。</p><h4 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h4><p>记录了<code>Redis</code>服务器及所在平台的信息，诸如服务器版本号、宿主机架构，创建<code>RDB</code>文件的时间戳、服务器占用的内存数量等。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>记录了 0 到多个数据库的数据，按数据库的号码从小到大。</p><p>每一个数据的数据结构为：</p><ul><li>数据库号码</li><li>键值对总数</li><li>带有过期时间的键值对数量</li><li>键值对数据部分</li></ul><p>载入的时候，首先根据数据库号码切换到指定的数据库。</p><p>然后服务器会根据第 2 部分和第 3 部分创建优化数据库的数据结构。</p><p>最后的键值对数据中，每一个键值对最多被划分为 5 个部分：</p><ul><li>过期时间</li><li><code>LRU</code>信息</li><li><code>LFU</code>信息</li><li>类型</li><li>键</li><li>值</li></ul><p><code>LRU</code>与<code>LFU</code>只会出现一个，因为<code>Redis</code>只能选择一种淘汰策略。</p><h4 id="Lua脚本缓存"><a href="#Lua脚本缓存" class="headerlink" title="Lua脚本缓存"></a><code>Lua</code>脚本缓存</h4><p>如果<code>Redis</code>启动了复制功能，那么服务器将在这里保存所有已被缓存的<code>Lua</code>脚本。</p><h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>用于标记<code>RDB</code>文件正文内容的末尾，它的值为二进制<code>0XFF</code>。当服务器读到这里的时候就知道正文部分结束了。</p><h4 id="CRC64校验和"><a href="#CRC64校验和" class="headerlink" title="CRC64校验和"></a><code>CRC64</code>校验和</h4><p>一个无符号 64 位整数。通过它来检验文件是否损坏。</p><h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入<code>RDB</code>文件</h3><pre class="mermaid">graph TB    A(打开文件)    B[检查文件标识符]    C[检查版本号]    D[读取设备信息]    E[重建数据库]    F[重建脚本缓存]    G[对比校验和]    H[载入完毕]    A-->B    B-->C    C-->D    D-->E    E-->F    F-->G    G-->H</pre><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>创建<code>RDB</code>文件的时间间隔决定了发生问题时丢失的数据量成正比。<code>save</code>或者<code>bgsave</code>创建<code>RDB</code>文件是存储整个服务器包含的所有数据，频繁的执行这个操作必然影响计算资源性能，不可能以减小操作间隔的方式来保障数据安全。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><code>AOF</code>的全称为<code>append only file</code>。</p><p>它是将数据库操作命令增量的保存到一个文件中。</p><h3 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly &lt; yes | no &gt;</span><br></pre></td></tr></table></figure><p>配置开关。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置<code>AOF</code>文件名，默认为<code>&quot;appendonly.aof&quot;</code>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync &lt; always | <span class="type">everysec</span> | <span class="type">no</span> &gt;</span><br></pre></td></tr></table></figure><p>向磁盘刷数据的频率：</p><ul><li><code>always</code>执行一次命令就同步一次（太频繁）</li><li><code>everysec</code>每秒同步一次（默认值）</li><li><code>no</code>不主动同步，具体什么时候同步要依靠系统（不确定性太大，数据丢失隐患大）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="string">&lt;</span> <span class="literal">yes</span> <span class="string">|</span> <span class="literal">no</span> <span class="string">&gt;</span></span><br></pre></td></tr></table></figure><p>配置<code>AOF</code>重写。如果只是增量的向文件添加命令，那么可能会造成命令的大量冗余（如对同一个字符串的多次<code>set</code>操作，实际只记录最后一次即可）。</p><p><code>Redis</code>提供了<code>AOF</code>重写功能来生成新的<code>AOF</code>文件，文件包含恢复当前数据库所需的尽可能少的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件增大的比例，如服务器启动时AOF文件为100M，如果percent值为100，那么代表在文件增大到200时触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage &lt;percent&gt; </span><br><span class="line"><span class="comment"># AOF文件的体积，当达到size时自动触发AOF重写</span></span><br><span class="line">auto-aof-rewrite-min-size &lt;size&gt;</span><br></pre></td></tr></table></figure><p>配置<code>AOF</code>重写自动触发频率。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">aof-load-truncated</span> <span class="string">&lt;</span> <span class="literal">yes</span> <span class="string">|</span> <span class="literal">no</span> <span class="string">&gt;</span></span><br></pre></td></tr></table></figure><p><code>AOF</code>文件中可能存在被截断的命令（正在向<code>AOF</code>文件添加命令的时候系统崩溃了），在通过<code>AOF</code>文件进行数据恢复时遇到这种有问题的指令如何处理就由这个选项配置，<code>yes</code>会忽略这条指令然后继续加载，<code>no</code>的话就解决数据恢复失败。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>可以通过<code>bgrewriteaof</code>命令手动触发。它会创建一个子进程，创建完成后退出并通知父进程替换掉旧的<code>AOF</code>文件。</p><h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>因为<code>AOF</code>文件存储的是命令的<code>Redis</code>网络协议格式的文本，所以其体积要比同数据量的<code>RDB</code>文件要大。</li><li>在恢复数据时，<code>RDB</code>是直接恢复，而<code>AOF</code>要执行命令，所以<code>RDB</code>的恢复效率更高。</li><li><code>AOF</code>重写的<code>bgrewriteaof</code>命令也需要创建子进程，在数据库体积较大的情况下进行<code>AOF</code>重写将占用大量资源，并短暂阻塞。</li></ul><pre class="mermaid">graph TB    A(载入AOF文件)    B{命令截断选项}    C[执行命令]    D[失败]    E[成功]    A-->B    B--no-->D    B--yes-->C    C-->E</pre><h2 id="AOF-与-RDB-混合持久化"><a href="#AOF-与-RDB-混合持久化" class="headerlink" title="AOF 与 RDB 混合持久化"></a>AOF 与 RDB 混合持久化</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">aof-use-rdb-preamble</span> <span class="string">&lt;</span> <span class="literal">yes</span> <span class="string">|</span> <span class="literal">no</span> <span class="string">&gt;</span></span><br></pre></td></tr></table></figure><p>通过这个选项来开启<code>RDB</code>与<code>AOF</code>混合持久化。</p><p>这个选项开启后，在进行<code>AOF</code>重写时，就会像进行<code>bgsave</code>那样，将当前的数据快照生成相应的<code>RDB</code>数据，但是这时不会生成<code>RDB</code>文件，而是将生成的<code>RDB</code>数据内容添加到<code>AOF</code>文件中（也就是生成了新的<code>AOF</code>文件，但是内容是<code>RDB</code>数据）。</p><p>之后<code>redis</code>执行的命令会也会以网络协议文本的形式继续添加到现有的<code>AOF</code>文件末尾。</p><p>所以在开启了这个选项之后，生成的<code>AOF</code>文件包含两个部分</p><ul><li><code>RDB</code>数据部分</li><li><code>AOF</code>命令协议文本部分</li></ul><p>恢复数据时的载入逻辑：</p><ul><li>判断文件开头是否包含<code>RDB</code>数据，如包含则先载入<code>RDB</code>数据再载入之后的<code>AOF</code></li><li>若只包含<code>AOF</code>数据，那么服务器将直接载入<code>AOF</code>数据</li></ul><pre class="mermaid">graph TB    A[打开AOF文件]    B{是否包含RDB数据}    C(载入RDB数据)    D(载入AOF数据)    E[数据载入完毕]    A-->B    B--yes-->C    B--no-->D    C-->D    D-->E</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;的所有数据都在内存中，断电后将全部丢失。数据的持久化功能就是为了解决这一问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;提供了&lt;code&gt;RDB&lt;/code&gt;、&lt;code&gt;AOF&lt;/code&gt;以及&lt;code&gt;RDB-AOF&lt;/code&gt;混合模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="//sunxingboo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>sort与uniq命令的使用</title>
    <link href="2020/03/19/sort-uniq/"/>
    <id>2020/03/19/sort-uniq/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2021-07-09T10:35:56.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>sort命令</strong>将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p><p><strong>uniq命令</strong>用于报告或忽略文件中的重复行，一般与sort命令结合使用。</p></blockquote><a id="more"></a><p><strong>sort命令的选项参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b--ignore-leading-blanks默认情况下整行都会进行排序，添加这个选项sort会忽略行开头的空格，从第一个非空白字符开始排序</span><br><span class="line">-f--ignore-case排序时不区分字母大小写</span><br><span class="line">-n--numeric-sort按数值大小排序</span><br><span class="line">-r--reverse逆序排序</span><br><span class="line">-k--key=filed1[,filed2]对指定的列进行排序，而不是整个文本行</span><br><span class="line">-m--merge将每个输入参数当作以排好序的文件名。将多个文件合并为一个排好序的文件而不执行额外的排序操作</span><br><span class="line">-o--output=file将排序结果输出到文件而不是标准输出</span><br><span class="line">-t--filed-separator=char定义字段分隔符，默认分隔符为空格或制表符</span><br><span class="line">-u --unique去除重复行并排序</span><br></pre></td></tr></table></figure><p><code>-k</code>选项的用法相对比较复杂</p><p>创建一段示例文本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">50</span> baidu</span><br><span class="line">d <span class="number">2000</span> ali</span><br><span class="line">e <span class="number">50</span> google</span><br><span class="line">c <span class="number">30</span> byte</span><br><span class="line">b <span class="number">100</span> jd</span><br></pre></td></tr></table></figure><p>直接用<code>sort</code>排序</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sort data.txt</span><br><span class="line">a <span class="number">50</span> baidu</span><br><span class="line">b <span class="number">100</span> jd</span><br><span class="line">c <span class="number">30</span> byte</span><br><span class="line">d <span class="number">2000</span> ali</span><br><span class="line">e <span class="number">50</span> google</span><br></pre></td></tr></table></figure><p>使用<code>-k</code>选项指定排序第二行，不指定结束字段的话默认从指定字段扩展到行尾，也就是说<code>-k 2</code>在下面的第一个示例排序中其实是等价于<code>-k 2,3</code>的。</p><p>但是当增加了<code>-n</code>选项时，不会默认扩展到行尾，也就是说<code>-k 2n</code>不等价于<code>-k 2,3n</code>、<code>-k 2n,3</code>、<code>-k 2n,3n</code>，这是因为按数值排序则程序只能识别数字前的符号<code>-</code>，除此之外当遇到其他非数字时就会终止此次排序。因此<code>-k 2n</code>等价于<code>-k 2,2n</code>、<code>-k 2n,2</code>、<code>-k 2n,2n</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sort -k 2 data.txt<span class="comment">#这里第二列按字符顺序进行了排序，使用-n选项排序才符合预期</span></span><br><span class="line">b 100 jd</span><br><span class="line">d 2000 ali</span><br><span class="line">c 30 byte</span><br><span class="line">a 50 baidu</span><br><span class="line">e 50 google</span><br><span class="line">$ sort -k 2n data.txt<span class="comment">#也可以写为 sort -k 2 -n data.txt</span></span><br><span class="line">c 30 byte</span><br><span class="line">a 50 baidu</span><br><span class="line">e 50 google</span><br><span class="line">b 100 jd</span><br><span class="line">d 2000 ali</span><br></pre></td></tr></table></figure><p>指定字段字符进行排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sort -k 3.2 data.txt</span><br><span class="line">d 2000 ali</span><br><span class="line">a 50 baidu</span><br><span class="line">c 30 byte</span><br><span class="line">e 50 google</span><br><span class="line">b 100 jd</span><br><span class="line">$ sort -k 3.2,3.3 data.txt <span class="comment">#对第三列的第二个字符开始到第三个字符进行排序</span></span><br></pre></td></tr></table></figure><p><strong>uniq命令的选项参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c--count在每一行前显示该行出现的次数</span><br><span class="line">-d--repeated仅显示重复出现的行</span><br><span class="line">-f n--skip-fileds=num忽略每行的前n个字段，字段间以空格分开（uniq命令无法指定分隔符）</span><br><span class="line">-i--ignore-case行与行之间比较时忽略大小写</span><br><span class="line">-s c--skip-chars=chars忽略每行的前c个字符</span><br><span class="line">-u--unique仅输出不重复的行，此选项是默认的</span><br></pre></td></tr></table></figure><p>测试文本</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">aaa</span><br><span class="line">ccc</span><br><span class="line">aaa</span><br><span class="line">eee</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><p><code>uniq</code>命令基本要配合<code>sort</code>命令，在排序好文件之后使用。先单独尝试一下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ uniq -c data.txt</span><br><span class="line">1 aaa</span><br><span class="line">1 bbb</span><br><span class="line">1 aaa</span><br><span class="line">1 ccc</span><br><span class="line">1 aaa</span><br><span class="line">1 eee</span><br><span class="line">1 ddd</span><br><span class="line"><span class="comment"># 每一行前都标注了出现一次，但是并没有进行统计</span></span><br><span class="line">$ sort data.txt | uniq -c</span><br><span class="line">3 aaa</span><br><span class="line">1 bbb</span><br><span class="line">1 ccc</span><br><span class="line">1 ddd</span><br><span class="line">1 eee</span><br><span class="line"><span class="comment"># 排序并进行了出现次数统计</span></span><br></pre></td></tr></table></figure><p>与之类似，<code>-u</code>参数只能去除相邻的重复行，<code>-d</code>参数只能输出相邻的重复行。</p><p><strong>使用案例</strong></p><p>获取系统中最常使用前十个命令以及使用的总次数</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ history | awk -F <span class="string">" "</span> '&#123;print $<span class="number">2</span>&#125;' | sort | uniq -c | sort -k <span class="number">1</span>bnr | head <span class="number">-10</span></span><br><span class="line"> <span class="number">234</span> ls</span><br><span class="line"> <span class="number">115</span> git</span><br><span class="line">  <span class="number">92</span> cd</span><br><span class="line">  <span class="number">54</span> echo</span><br><span class="line">  <span class="number">51</span> ssh</span><br><span class="line">  <span class="number">41</span> vim</span><br><span class="line">  <span class="number">40</span> cat</span><br><span class="line">  <span class="number">34</span> rm</span><br><span class="line">  <span class="number">27</span> mv</span><br></pre></td></tr></table></figure><ul><li>首先将<code>history</code>的输出管道到<code>awk</code></li><li><code>awk</code>指定以空格为分隔符，输出第二列（也就是具体命令列）</li><li>管道到<code>sort</code>进行排序</li><li>之后将结果管道到<code>uniq</code>为每条命令进行计数</li><li>然后继续将结果管道到<code>sort</code>根据第一列按数值倒序排序</li><li>最后利用<code>head</code>取结果的前十条</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;sort命令&lt;/strong&gt;将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;uniq命令&lt;/strong&gt;用于报告或忽略文件中的重复行，一般与sort命令结合使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引笔记</title>
    <link href="2020/03/17/mysql-index/"/>
    <id>2020/03/17/mysql-index/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2021-07-09T10:25:36.689Z</updated>
    
    <content type="html"><![CDATA[<p>提到索引，就会看到诸如聚簇索引、非聚簇索引、主键索引、唯一索引、普通索引、哈希索引、全文索引、B树索引……经常搞混，特此整理一篇索引笔记以供查阅。</p><a id="more"></a><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p><strong>二叉树</strong></p><p>基于平衡二叉树的查找相当于二分查找，数据的比较次数较少，但是数据量较大时，树的高度较高，查询时会产生大量的磁盘<code>IO</code>，效率极差。如下图，每一个节点就会进行一次磁盘<code>IO</code>，与查询的数据进行比对后决定查询方向。</p><p>另一方面，可能会随着数据的变化退化为单链表。</p><p><strong>红黑树</strong></p><p>自动进行平衡的二叉树，防止退化为单链表。如上例数据进行删减后，红黑树会自动平衡生成新的平衡二叉树。</p><p><strong>B树</strong></p><p>B树是一颗多路平衡树，每一个节点存储多个关键字以及对应的数据，并存储指向下一层节点的指针。因为节点还存有实际数据的原因，因此每个节点存储的关键字比B+树少，数据量较大时树的高度会略高。</p><p><strong>B+树</strong></p><p>在B树的基础上扩展，非叶子节点只存储关键字，因此每个节点能存储更多的关键字，所以树的高度较低，磁盘<code>IO</code>次数较少。并且每个节点还存有相邻节点的指针，有利于进行范围查询。实际数据只存储在叶子节点，因此对于每一次查询都需要所搜到最后，但是由于树的高度较低，所以平均效率较好。</p><p><strong>哈希</strong></p><p>通过哈希算法计算数据的哈希值，得到数据的存放位置，当发生哈希碰撞时在哈希值所在位置创建一个链表来存放相同哈希值的数据。</p><p>在数据量很大的情况下内存无法加载全部的数据索引。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p><strong>聚簇索引</strong></p><p>聚簇索引指的是节点中存储着实际数据的索引，查找到了索引也就找到了数据。一个表只有一个聚簇索引，通常为主键索引，如果没有为表指定主键，实际上系统会隐式创建一个聚簇索引。</p><p>可以理解为主索引，每一次查询实际最后查到数据都是利用这个主索引。</p><p><strong>非聚簇索引</strong></p><p>非聚簇索引指的是节点存储的是真实数据的主键，需要利用查询到的主键值再到主索引进行一次查询。例如复合索引、唯一索引、前缀索引。</p><h2 id="MySQL的索引类型"><a href="#MySQL的索引类型" class="headerlink" title="MySQL的索引类型"></a>MySQL的索引类型</h2><p><strong>主键索引</strong></p><p>一个表最多只有一个，值唯一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">  id int not null auto_increment,</span><br><span class="line">  name varchar(10)</span><br><span class="line">  primary key(id)</span><br><span class="line">);</span><br><span class="line">alter table test add constraint pk primary key(id);</span><br><span class="line">#对于字符串字段还可以指定索引长度 name(10)</span><br></pre></td></tr></table></figure><p><strong>普通索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">  name varchar(10)</span><br><span class="line">  index idx_name(name)</span><br><span class="line">);</span><br><span class="line">create index idx_name on test(name);</span><br><span class="line">alter table test add index idx_name(name);</span><br><span class="line">#对于字符串字段还可以指定索引长度 name(10)</span><br></pre></td></tr></table></figure><p><strong>唯一索引</strong></p><p>索引列的值必须唯一，但可以为空值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">  name varchar(10)</span><br><span class="line">  unique idx_unique_name(name)</span><br><span class="line">);</span><br><span class="line">create unique index idx_unique_name on test(name);</span><br><span class="line">alter table test add unique index idx_unique_name(name);</span><br><span class="line">#对于字符串字段还可以指定索引长度 name(10)</span><br></pre></td></tr></table></figure><p><strong>联合索引 / 组合索引 / 复合索引</strong></p><p>指定多个字段创建索引。如（a, b, c），则在查询条件中（a）、（a, b）、（a, c）、（a, b, c）这几种<code>and</code>组合时，索引才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">  name varchar(10),</span><br><span class="line">  age tinyint,</span><br><span class="line">  index idx_name_age(name, age)</span><br><span class="line">);</span><br><span class="line">create index idx_name_age on test(name, age);</span><br><span class="line">alter table test add index idx_name_age(name, age);</span><br><span class="line">#对于字符串字段还可以指定索引长度 name(10)</span><br></pre></td></tr></table></figure><p><strong>全文索引</strong></p><p>主要用来查找文本中的关键字，少量的数据可以使用<code>like</code>，但当文本数据较大时这种方式效率是很低的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">  id int not null auto_increment,</span><br><span class="line">  title varchar(100) not null default &quot;&quot;,</span><br><span class="line">  content text null,</span><br><span class="line">  primary key(id),</span><br><span class="line">  fulltext(contents)</span><br><span class="line">);</span><br><span class="line">create fulltext index idx_fulltext_content on test(content);</span><br><span class="line">alter table test add fulltext index idx_fulltext_content(content);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到索引，就会看到诸如聚簇索引、非聚簇索引、主键索引、唯一索引、普通索引、哈希索引、全文索引、B树索引……经常搞混，特此整理一篇索引笔记以供查阅。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="//sunxingboo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的SUID、SGID、SBIT权限设置与作用</title>
    <link href="2020/03/13/linus-uid-gid-bit/"/>
    <id>2020/03/13/linus-uid-gid-bit/</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2021-07-09T10:25:15.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p><code>SUID</code>只能对文件设置</p><ul><li>只对二进制可执行文件有效</li><li>执行者对文件有<code>x</code>权限，在执行此程序期间获取到程序所有者的身份</li></ul><p>普通的文件权限</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-rwxrwxr-x</span></span><br></pre></td></tr></table></figure><p>设置了<code>SUID</code>位的文件权限，拥有者的<code>x</code>变为<code>s</code>。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-rwsrwxr-x</span></span><br></pre></td></tr></table></figure><p>设置方法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">4</span>xxx &lt;name&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>做一个实验验证，创建两个测试用户<code>test-1 test-2</code>，登陆到<code>test-1</code>并在家目录创下创建一个文件<code>data.log</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">============</span><br><span class="line"><span class="built_in">test</span>-1 data</span><br><span class="line">============</span><br></pre></td></tr></table></figure><p>切换到<code>/tmp</code>目录，建立一个读取<code>data.log</code>的脚本，并为其分配<code>755</code>权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat /home/<span class="built_in">test</span>-1/data.log</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 readlog.sh</span><br></pre></td></tr></table></figure><p>现在切换到<code>test-2</code>用户，执行一下这个脚本看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su <span class="built_in">test</span>-2</span><br><span class="line">$ /tmp/readlog.sh</span><br><span class="line">cat: /home/<span class="built_in">test</span>-1/data.log: Permission denied</span><br></pre></td></tr></table></figure><p>肯定是没有权限读取的，切回<code>test-1</code>用户，给脚本设置<code>SUID</code>位，然后再切回<code>test-2</code>并执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ su <span class="built_in">test</span>-1</span><br><span class="line">$ chmod 4755 readlog.sh</span><br><span class="line">$ su <span class="built_in">test</span>-2</span><br><span class="line">$ /tmp/readlog.sh</span><br><span class="line">$ cat: /home/<span class="built_in">test</span>-1/data.log: Permission denied</span><br></pre></td></tr></table></figure><p>此时依然无法读取，说明对于<code>shell</code>脚本，<code>SUID</code>的设置是没有作用的。</p><p>这里我切到<code>test-1</code>写一段<code>go</code>程序，并编译成二进制文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"readlog is running..."</span>)</span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"/home/test-1/data.log"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"File reading error"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Contents of file:"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build readlog.go</span><br></pre></td></tr></table></figure><p>切回<code>test-2</code>，执行这个二进制文件，没有权限。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /tmp/readlog</span><br><span class="line">readlog is <span class="built_in">running</span>...</span><br><span class="line"><span class="built_in">File</span> reading error <span class="built_in">open</span> /<span class="built_in">home</span>/test<span class="number">-1</span>/data.<span class="built_in">log</span>: permission denied</span><br></pre></td></tr></table></figure><p>我们切回<code>test-1</code>并给这个二进制文件设置<code>SUID</code>位，再切回<code>test-2</code>执行，已经可以读取到<code>test-1</code>用户家目录下的文件了，说明这个执行过程中<code>test-2</code>用户获取到了<code>test-1</code>的身份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 4755 readlog</span><br><span class="line">$ su <span class="built_in">test</span>-2</span><br><span class="line">$ /tmp/readlog</span><br><span class="line">readlog is running...</span><br><span class="line">Contents of file: <span class="built_in">test</span>-1 data</span><br></pre></td></tr></table></figure><h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p><code>SGID</code>可以对文件或目录设置</p><ul><li><p>文件</p><ul><li>对二进制文件有效</li><li>执行者对文件有<code>x</code>权限，在执行期间获取到程序所属群组的权限</li></ul></li><li><p>目录</p><ul><li>对目录有<code>r</code>和<code>x</code>权限的用户可以进入目录</li><li>用户在此目录下的有效群组将会变为该目录的群组</li><li>若用户在此目录具有<code>w</code>权限，则其创建的文件的所属群组与此目录的所属群组相同</li></ul></li></ul><p>普通文件权限</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-rwxrwxr-x</span></span><br></pre></td></tr></table></figure><p>设置了<code>SGID</code>权限，所属组的<code>x</code>变为<code>s</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-rwxrwsr-x</span></span><br></pre></td></tr></table></figure><p>设置方法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">2</span>xxx &lt;name&gt;</span><br></pre></td></tr></table></figure><p>建立一个测试群组，创建一个目录并分配到这个群组上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd sgid-test</span><br><span class="line">$ mkdir /tmp/sgid-test</span><br><span class="line">$ chgrp /tmp/sgid-test sgid-test</span><br><span class="line">$ ls /tmp/</span><br><span class="line">drwxr-xr-x. 2 root   sgid-test       6 3月  14 16:10 sgid-test</span><br></pre></td></tr></table></figure><p>切换到<code>test-1</code>在这个目录创建一个文件试试看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ su <span class="built_in">test</span>-1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test1"</span> &gt; /tmp/sgid-test/data.txt</span><br><span class="line">$ ls /tmp/sgid-test/</span><br><span class="line">-rw-rw-r--. 1 <span class="built_in">test</span>-1 <span class="built_in">test</span>-1 4 3月  14 16:14 data.txt</span><br></pre></td></tr></table></figure><p>这时创建的文件属于<code>test-1</code>用户和<code>test-1</code>分组</p><p>切回管理员账户并给改目录设置<code>SGID</code>，再用<code>test-1</code>创建一个文件试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ su -</span><br><span class="line">$ chmod 2777 /tmp/sgid-test</span><br><span class="line">$ ls /tmp/</span><br><span class="line">drwxrwsrwx. 2 root   sgid-test      22 Mar 14 16:14 sgid-test</span><br><span class="line">$ su <span class="built_in">test</span>-1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test2"</span> &gt; /tmp/sgid-test/data2.txt</span><br><span class="line">$ ls /tmp/sgid-test/</span><br><span class="line">-rw-rw-r--. 1 <span class="built_in">test</span>-1 sgid-test 4 Mar 14 16:15 data2.txt</span><br></pre></td></tr></table></figure><p>可以看到这时<code>test-1</code>创建的文件属于<code>test-1</code>用户和<code>sgid-test</code>分组</p><h2 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h2><p><code>SBIT</code>只能对目录设置，设置了该权限之后，对此目录有<code>w</code>和<code>x</code>权限的用户，在该目录内创建的文件之后用户自己与<code>root</code>有权限删除。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwt.   <span class="number">8</span> root root       <span class="number">177</span> Mar <span class="number">14</span> <span class="number">16</span>:<span class="number">55</span> tmp</span><br></pre></td></tr></table></figure><p><code>test-1</code>在<code>/tmp</code>创建文件并给予全部权限，再切到<code>test-2</code>对其进行一些操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"test"</span> &gt; /tmp/test.txt</span><br><span class="line">$ chmod 777 /tmp/test.txt</span><br><span class="line">$ su <span class="built_in">test</span>-2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"line2"</span> &gt;&gt; /tmp/test.txt <span class="comment">#可以正常编辑</span></span><br><span class="line">$ rm /tmp/test.txt</span><br><span class="line">rm: cannot remove ‘test.txt’: Operation not permitted<span class="comment">#但是不能删除</span></span><br></pre></td></tr></table></figure><h2 id="空权限"><a href="#空权限" class="headerlink" title="空权限"></a>空权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rw-r--r--. 1 root root 4 Mar 14 17:02 s-test</span><br></pre></td></tr></table></figure><p>此文件的所有者、所属组及其他人均没有<code>x</code>权限，此时设置<code>SUID</code>、<code>SGID</code>、<code>SBIT</code>来看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 7644 s-test</span><br><span class="line">$ ls -l</span><br><span class="line">$ -rwSr-Sr-T. 1 root root 4 Mar 14 17:02 s-test</span><br></pre></td></tr></table></figure><p>可以发现对于没有<code>x</code>权限的文件设置这三种属性，则<code>x</code>权限位分别变为<code>S</code>、<code>S</code>和<code>T</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SUID&quot;&gt;&lt;a href=&quot;#SUID&quot; class=&quot;headerlink&quot; title=&quot;SUID&quot;&gt;&lt;/a&gt;SUID&lt;/h2&gt;&lt;p&gt;&lt;code&gt;SUID&lt;/code&gt;只能对文件设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只对二进制可执行文件有效&lt;/li&gt;
&lt;li&gt;执行者对文件有&lt;code&gt;x&lt;/code&gt;权限，在执行此程序期间获取到程序所有者的身份&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普通的文件权限&lt;/p&gt;
&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;deletion&quot;&gt;-rwxrwxr-x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置了&lt;code&gt;SUID&lt;/code&gt;位的文件权限，拥有者的&lt;code&gt;x&lt;/code&gt;变为&lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;deletion&quot;&gt;-rwsrwxr-x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置方法&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;xxx &amp;lt;name&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell表达式判断</title>
    <link href="2020/03/12/shell-test/"/>
    <id>2020/03/12/shell-test/</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2021-07-09T10:28:59.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>test expression</p><p>[ expression ]</p></blockquote><a id="more"></a><p><strong>测试文件的表达式</strong></p><div class="table-container"><table><thead><tr><th>表达式</th><th>为true的条件</th></tr></thead><tbody><tr><td>file1 -ef file2</td><td>file1与file2两个文件通过硬连接指向同一个文件</td></tr><tr><td>file1 -nt file2</td><td>file1比file2新</td></tr><tr><td>file1 -ot file2</td><td>file1比file2旧</td></tr><tr><td>-b file</td><td>file存在且是一个块（设备）文件</td></tr><tr><td>-c file</td><td>file存在且是一个字符（设备）文件</td></tr><tr><td>-d file</td><td>file存在且是一个目录</td></tr><tr><td>-e file</td><td>file存在</td></tr><tr><td>-f file</td><td>file存在且是一个普通文件</td></tr><tr><td>-g file</td><td>file存在且设置了组ID</td></tr><tr><td>-G file</td><td>file存在且属于有效组ID</td></tr><tr><td>-k file</td><td>file存在且有粘滞位属性</td></tr><tr><td>-L file</td><td>file存在且是一个符号链接</td></tr><tr><td>-O file</td><td>file存在并且属于有效用户ID</td></tr><tr><td>-p file</td><td>file存在并且是一个命名管道</td></tr><tr><td>-r file</td><td>file存在且可读</td></tr><tr><td>-s file</td><td>file存在且其长度大于0</td></tr><tr><td>-S file</td><td>file存在且是一个网络套接字</td></tr><tr><td>-t fd</td><td>fd是一个定向到终端/从终端定向的文件描述符，可以用来确定标准输入/输出/错误是否被重定向</td></tr><tr><td>-u file</td><td>file存在且设置了setuid位</td></tr><tr><td>-w file</td><td>file存在且可写</td></tr><tr><td>-x file</td><td>file存在且可执行</td></tr></tbody></table></div><p><strong>测试字符串的表达式</strong></p><div class="table-container"><table><thead><tr><th>表达式</th><th>为true的条件</th></tr></thead><tbody><tr><td>string</td><td>string不为空</td></tr><tr><td>-n string</td><td>string长度大于0</td></tr><tr><td>-z string</td><td>string长度等于0</td></tr><tr><td>string1 = string2<br/>string1 == string2</td><td>相等</td></tr><tr><td>string1 != string2</td><td>不等</td></tr><tr><td>string1 &gt; string2</td><td>经过排序后，string1在string2之后</td></tr><tr><td>string1 &lt; string2</td><td>经过排序后，string1在string2之前</td></tr></tbody></table></div><p><strong>测试数值的表达式</strong></p><div class="table-container"><table><thead><tr><th>表达式</th><th>为true的条件</th></tr></thead><tbody><tr><td>integer1 -eq integer2</td><td>integer1 等于 integer2</td></tr><tr><td>integer1 -ne integer2</td><td>integer1 不等于 integer2</td></tr><tr><td>integer1 -le integer2</td><td>integer1 小于等于 integer2</td></tr><tr><td>integer1 -lt integer2</td><td>integer1 小于 integer2</td></tr><tr><td>integer1 -ge integer2</td><td>integer1 大于等于 integer2</td></tr><tr><td>integer1 -gt integer2</td><td>integer1 大于 integer2</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;test expression&lt;/p&gt;
&lt;p&gt;[ expression ]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>树莓派系统安装及设置ssh开机启动</title>
    <link href="2020/03/11/raspberry-ssh/"/>
    <id>2020/03/11/raspberry-ssh/</id>
    <published>2020-03-10T16:00:00.000Z</published>
    <updated>2021-07-09T10:26:55.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>资源及工具</strong></p><ul><li><p>国内在官网下载系统镜像会很慢，经过搜索一番之后找到此<a href="https://www.jianshu.com/p/8446f7971d66" target="_blank" rel="noopener">高速资源</a>。</p></li><li><p>如需格式化 SD 卡可使用这款<a href="https://www.sdcard.org/downloads/index.html" target="_blank" rel="noopener">工具</a>。</p></li><li><p>使用 win32DiskImager 将系统写入 SD 卡</p></li></ul><p><strong>开启ssh服务</strong></p><p>开机尝试<code>ssh</code>登陆，请求被拒绝，对于这个问题有一些旧答案说需要在<code>/boot</code>分区下创建一个名为<code>ssh</code>的空白文件，并尝试重<code>sshd</code>服务。而实际上新版本的系统已经不需要这样设置了，只需要开启<code>ssh</code>服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start sshd</span><br><span class="line">//Unit sshd.service not found</span><br></pre></td></tr></table></figure><p>这条命令会报错。树莓派系统<code>ssh</code>服务名并不是<code>sshd</code>，而是<code>ssh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start ssh</span><br></pre></td></tr></table></figure><p>启动成功</p><p><strong>设置ssh开机自启</strong></p><p>这里只需要修改文件<code>/etc/rc.local</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/etc/init.d/ssh start  <span class="comment">#加入这一行</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;资源及工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;国内在官网下载系统镜像会很慢，经过搜索一番之后找到此&lt;a href=&quot;https://www.jianshu.com/p/8446f7971d66&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
      <category term="树莓派" scheme="//sunxingboo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>shell的变量扩展</title>
    <link href="2020/03/09/var-expand/"/>
    <id>2020/03/09/var-expand/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2021-07-09T10:32:08.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本扩展"><a href="#基本扩展" class="headerlink" title="基本扩展"></a>基本扩展</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ val=<span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val&#125;</span>1</span><br><span class="line">test1</span><br></pre></td></tr></table></figure><p><code>${val}</code>的形式可以明确界定变量名范围，比如上例用于拼接字符串。</p><a id="more"></a><h2 id="空变量的扩展"><a href="#空变量的扩展" class="headerlink" title="空变量的扩展"></a>空变量的扩展</h2><p><code>${val1:-val2}</code>，当<code>val1</code>未定义或为空时，将其扩展为<code>val2</code>的值，但并不改变<code>val1</code>；若<code>val1</code>已定义且非空，则扩展为<code>val1</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span> <span class="comment">#val1未定义</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val1:-"test"&#125;</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span>  <span class="comment">#仍为空</span></span><br></pre></td></tr></table></figure><p><code>${val1:=val2}</code>，当<code>val1</code>未定义或为空时，将其扩展为<code>val2</code>的值，并且将<code>val2</code>的值赋给<code>val1</code>；若<code>val1</code>已定义且非空，则扩展为<code>val1</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span> <span class="comment">#val1未定义</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val1:-"test"&#125;</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span>  <span class="comment">#val1被设为test</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><em>注意：这种方式不能给位置参数以及其他特殊参数赋值</em></p><p><code>${val1:?val2}</code>，当<code>val1</code>未定义或为空时，将<code>val2</code>的值输出到标准错误；若<code>val1</code>已定义且非空，则扩展为<code>val1</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val1:?"val1 is empty"&#125;</span></span><br><span class="line">-bash: val1: val1 is empty</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><code>${val1:+val2}</code>，当<code>val1</code>未定义或为空时，不进行扩展；若<code>val1</code>已定义且非空，则将其扩展为<code>val2</code>的值，并且不改变<code>val1</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span></span><br><span class="line"><span class="comment">#空</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val1:+"test2"&#125;</span></span><br><span class="line"><span class="comment">#空</span></span><br><span class="line">$ val1=test1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;val1:+"test2"&#125;</span></span><br><span class="line">test2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$val1</span></span><br><span class="line">test1 <span class="comment">#val1的值没有改变</span></span><br></pre></td></tr></table></figure><h2 id="返回变量名扩展"><a href="#返回变量名扩展" class="headerlink" title="返回变量名扩展"></a>返回变量名扩展</h2><p><code>${!word*}</code>与<code>${!word@}</code>，这两种形式的作用相同，返回以<code>word</code>为开头的所有变量名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!val*&#125;</span></span><br><span class="line">val1</span><br><span class="line">$ val2=test2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!val@&#125;</span></span><br><span class="line">val1 val2</span><br></pre></td></tr></table></figure><h2 id="更多字符串扩展"><a href="#更多字符串扩展" class="headerlink" title="更多字符串扩展"></a>更多字符串扩展</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;#str&#125;，其作用是扩展为`str`变量包含的字符串长度。</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#val&#125;</span></span><br><span class="line">0</span><br><span class="line">$ val=<span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#val&#125;</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><code>${str:offset:length}</code>，其作用为，从索引<code>offset</code>处开始截取<code>str</code>，截取长度为<code>length</code>，如过没有设置<code>length</code>，则一直截取到末尾。</p><p>如果<code>offset</code>为负数，则从字符串末尾倒数<code>offset</code>开始进行截取，并且在<code>offset</code>前必须添加一个空格，否则会被混淆为<code>${str:-&quot;val&quot;}</code>这种扩展形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ str=<span class="string">"test string"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str:2&#125;</span></span><br><span class="line">st string</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str:2:4&#125;</span></span><br><span class="line">st s</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str: -5:3&#125;</span></span><br><span class="line">tri</span><br></pre></td></tr></table></figure><p>如果参数是<code>@</code>，扩展的结果是从<code>offset</code>开始，<code>length</code>为位置参数。</p><p><code>${str#pattern}</code>与<code>${str##pattern}</code>，作用为从<em>字符串开头</em>开始去除字符串<code>str</code>中满足模式<code>pattern</code>的部分，这两种方式的区别是<code>#</code>去除最短匹配，而<code>##</code>去除最长匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ str=<span class="string">"test.tar.gz"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str#*.&#125;</span><span class="comment">#去除最短匹配</span></span><br><span class="line">tar.gz</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str##*.&#125;</span><span class="comment">#去除最长匹配</span></span><br><span class="line">gz</span><br></pre></td></tr></table></figure><p><code>${str%pattern}</code>与<code>${str%%pattern}</code>，作用为从<em>字符串末尾</em>开始去除字符串<code>str</code>中满足模式<code>pattern</code>的部分，这两种方式的区别是<code>%</code>去除最短匹配，而<code>%%</code>去除最长匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ str=<span class="string">"test.tar.gz"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str%.*&#125;</span><span class="comment">#去除最短匹配</span></span><br><span class="line">test.tar</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str%%.*&#125;</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>${str/pattern/replace}</code>，其作用为将字符串<code>str</code>中第一个符合<code>pattern</code>模式匹配的部分替换为<code>replace</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ str=<span class="string">"test.txt.txt"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/test/new-name&#125;</span></span><br><span class="line">new-name.txt.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/txt/suffix&#125;</span></span><br><span class="line">test.suffix.txt</span><br></pre></td></tr></table></figure><p><code>${str//pattern/replace}</code>，其作用为将字符串<code>str</code>中所有符合<code>pattern</code>模式匹配的部分替换为<code>replace</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str//txt/suffix&#125;</span></span><br><span class="line">test.suffix.suffix</span><br></pre></td></tr></table></figure><p><code>${str/#pattern/replace}</code>，<code>/#</code>的形式要求匹配出现在字符串开头。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/#txt/suffix&#125;</span></span><br><span class="line">test.txt.txt<span class="comment">#txt不在字符串开头，所以没有替换</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/#test/new-name&#125;</span></span><br><span class="line">new-name.txt.txt</span><br></pre></td></tr></table></figure><p><code>${str/%pattern/replace}</code>，<code>/%</code>的形式要求匹配出现在字符串末尾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/%test/new-name&#125;</span></span><br><span class="line">test.txt.txt<span class="comment">#test不在字符串末尾，所以没有替换</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;str/%txt/suffix&#125;</span></span><br><span class="line">test.txt.suffix</span><br></pre></td></tr></table></figure><p>如果不设置<code>replace</code>，这四种形式的扩展将去掉满足匹配模式<code>pattern</code>的部分。</p><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>数值计算的扩展使用<code>$(())</code>或<code>$[]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((1+2*3))</span><br><span class="line">7</span><br><span class="line">$ <span class="built_in">echo</span> $[1+2*3]</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>进制转换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((2<span class="comment">#1111))</span></span><br><span class="line">15</span><br><span class="line">$ <span class="built_in">echo</span> $((16<span class="comment">#ab))</span></span><br><span class="line">171</span><br><span class="line">$ <span class="built_in">echo</span> $[2<span class="comment">#1111]#不支持进制转换</span></span><br><span class="line">-bash: $: 未找到命令</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本扩展&quot;&gt;&lt;a href=&quot;#基本扩展&quot; class=&quot;headerlink&quot; title=&quot;基本扩展&quot;&gt;&lt;/a&gt;基本扩展&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ val=&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$val&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;val&amp;#125;&lt;/span&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;${val}&lt;/code&gt;的形式可以明确界定变量名范围，比如上例用于拼接字符串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell中的各种括号的作用 $()、${}、[]、[[]]、(())等</title>
    <link href="2020/03/08/shell-symbol/"/>
    <id>2020/03/08/shell-symbol/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2021-07-09T10:28:42.761Z</updated>
    
    <content type="html"><![CDATA[<p><code>shell</code>中有很多长相相似的括号命令，经常弄混，特此整理它们各自的作用。</p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title="$()"></a>$()</h2><p>用于执行命令并获取命令的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="built_in">echo</span> <span class="built_in">test</span> //第二个<span class="built_in">echo</span>无法执行，而是被当作字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="built_in">test</span>) //括号内的<span class="built_in">echo</span>被执行，整个表达式$(<span class="built_in">echo</span> <span class="built_in">test</span>)的结果为<span class="built_in">test</span>，然后第一个<span class="built_in">echo</span>命令继续执行，参数为<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>另一种执行命令的方式是用反引号 ``</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="built_in">test</span>`</span><br></pre></td></tr></table></figure><p>用反引号的移植性更好，基本所有的<code>shell</code>都支持这种方式，而<code>$()</code>方式的可读性更好</p><h2 id="-1"><a href="#-1" class="headerlink" title="${}"></a>${}</h2><p>用于解析变量及精确界定变量名称的范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ name=<span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$name2</span>    //预期输出test2，但是输出为空，shell认为此时的变量名为name2，而name2未定义</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span>2  //使用<span class="variable">$&#123;name&#125;</span>明确界定出了变量name的变量名范围，与2构成test2字符串</span><br><span class="line">test2</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><p>等同于<code>test</code>命令，用于判断给定的表达式是否成立</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ [1 -eq 2]</span><br><span class="line">zsh: bad pattern: [1</span><br></pre></td></tr></table></figure><p>使用<code>[]</code>时，左括号的右侧和右括号的左侧必须有一个以上的空格，不然会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ [ 1 &gt; 2 ]//会在当前目录生成一个名为2的文件</span><br><span class="line">$ [ 1 &lt; 2 ] //会尝试读取名为2的文件，若不存在则会报错，若存在此表达式被判断为真</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ [ 1 \&gt; 2 ]</span><br><span class="line">$ [ 1 \&lt; 2 ]</span><br></pre></td></tr></table></figure><p>若使用<code>&gt;</code>及<code>&lt;</code>则必须进行转译，不然会被认为是重定向</p><h2 id="-3"><a href="#-3" class="headerlink" title="[[]]"></a>[[]]</h2><p><code>[[]]</code>是<code>test</code>及<code>[]</code>命令的增强版，增加了一个字符串表达式<code>string=~regex</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [[ <span class="string">"test"</span> =~ ^-?[0-9]+$ ]]</span><br></pre></td></tr></table></figure><p>在<code>[[]]</code>中使用<code>&lt;</code>和<code>&gt;</code>，不需要转译</p><p>在<code>[[]]</code>中的<code>==</code>支持模式匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file=test.txt</span><br><span class="line">$ [[ <span class="variable">$file</span> == <span class="built_in">test</span>.* ]]</span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title="(())"></a>(())</h2><p><code>(())</code>是为整数设计的，只能用于处理整数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (( <span class="string">""</span> == <span class="string">"t"</span> )) //报错</span><br><span class="line">$ (( 1 == 2 ))//<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>与<code>[[]]</code>类似，<code>(())</code>中使用<code>&lt;</code>和<code>&gt;</code>也是不需要转译的</p><h2 id="与"><a href="#与" class="headerlink" title="$[]与$(())"></a>$[]与$(())</h2><p><code>$[]</code>与<code>$(())</code>是相同的，都是用于数学运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这里的左括号右边与右括号左边的空格不是必须的</span><br><span class="line">$ <span class="built_in">echo</span> $(( (5+1)/2%2 ))</span><br><span class="line">1</span><br><span class="line">$ <span class="built_in">echo</span> $[ (5+1)/2%2 ]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>默认的输出结果为十进制，<code>$(())</code>还可以进行不同进位的运算（二进制、八进制、十六进制等转为十进制），指定进制及数值，输出其十进制的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//$(( 进制<span class="comment">#数值 ))</span></span><br><span class="line">$ <span class="built_in">echo</span> $(( 2<span class="comment">#10 )) //2</span></span><br><span class="line">$ <span class="built_in">echo</span> $(( 8<span class="comment">#12 )) //10</span></span><br><span class="line">$ <span class="built_in">echo</span> $(( 16<span class="comment">#B )) //11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中有很多长相相似的括号命令，经常弄混，特此整理它们各自的作用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell位置参数</title>
    <link href="2020/03/08/shell-params/"/>
    <id>2020/03/08/shell-params/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2021-07-09T10:26:30.740Z</updated>
    
    <content type="html"><![CDATA[<p><code>shell</code>提供了一组变量，用来存储传递给脚本或函数的参数</p><a id="more"></a><h2 id="0-9以及更多的位置参数扩展"><a href="#0-9以及更多的位置参数扩展" class="headerlink" title="$0~$9以及更多的位置参数扩展"></a>$0~$9以及更多的位置参数扩展</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> posit-param</span></span><br><span class="line">echo -e "\$0 = $0"</span><br><span class="line">echo -e "\$1 = $1"</span><br><span class="line">echo -e "\$2 = $2"</span><br><span class="line">echo -e "\$3 = $3"</span><br><span class="line">echo -e "\$4 = $4"</span><br><span class="line">echo -e "\$5 = $5"</span><br><span class="line">echo -e "\$6 = $6"</span><br><span class="line">echo -e "\$7 = $7"</span><br><span class="line">echo -e "\$8 = $8"</span><br><span class="line">echo -e "\$9 = $9"</span><br></pre></td></tr></table></figure><p>执行这个脚本，输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./posit-param</span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 = ./posit-param.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">3 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">4 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">5 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">6 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">7 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">8 =</span></span><br><span class="line"><span class="meta">$</span><span class="bash">9 =</span></span><br></pre></td></tr></table></figure><p><code>$0</code>存储的是所执行的程序所在的完成路径名，没有传递其他参数，则其他位置参数为空</p><p>在脚本内增加一行接收第十个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo -e "\$10 = $10"</span><br></pre></td></tr></table></figure><p>执行脚本，传递十个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./posit-param a b c d e f g h i j</span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 = ./posit-param.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = a</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = b</span></span><br><span class="line"><span class="meta">$</span><span class="bash">3 = c</span></span><br><span class="line"><span class="meta">$</span><span class="bash">4 = d</span></span><br><span class="line"><span class="meta">$</span><span class="bash">5 = e</span></span><br><span class="line"><span class="meta">$</span><span class="bash">6 = f</span></span><br><span class="line"><span class="meta">$</span><span class="bash">7 = g</span></span><br><span class="line"><span class="meta">$</span><span class="bash">8 = h</span></span><br><span class="line"><span class="meta">$</span><span class="bash">9 = i</span></span><br><span class="line"><span class="meta">$</span><span class="bash">10 = a0  //没有接收到参数</span></span><br></pre></td></tr></table></figure><p>可以通过参数扩展来接收第十个及更多的参数，将最后一行改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo -e "\$10 = $&#123;10&#125;" #这样可以正常获取参数输出啦</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="$"></a>$</h2><p><code>$#</code>存储的是传递给脚本或者函数的参数的个数</p><p>在<code>posit-param</code>脚本内加一行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo -e "params number is $# \n"</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./posit-param a b c d e f g h i j</span><br><span class="line">params number is 10</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="shift用于处理大量参数"><a href="#shift用于处理大量参数" class="headerlink" title="shift用于处理大量参数"></a>shift用于处理大量参数</h2><p><code>shift</code>命令的作用是把除了<code>$0</code>以外的全部位置参数向左移动指定的间隔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">shift #左移一位，$1被丢弃，$2移到$1，$3移到$2...</span><br><span class="line">shift 2 #左移两位，$1与$2被丢弃，$3移到$1，$4移到$2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>示例脚本如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> posit-param2</span></span><br><span class="line">count=1</span><br><span class="line">while [ $# -ne 0 ]; do</span><br><span class="line">  echo "param $count is $1"</span><br><span class="line">  count=$(( count + 1 ))</span><br><span class="line">  shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./posit-param2 a b c</span><br><span class="line">param 1 is a</span><br><span class="line">param 2 is b</span><br><span class="line">param 3 is c</span><br></pre></td></tr></table></figure><h2 id="与"><a href="#与" class="headerlink" title="$*与$@"></a>$*与$@</h2><p><code>$*</code>扩展为从<code>1</code>开始的位置参数列表。当被双引号包裹时（<code>&quot;$*&quot;</code>），将全部位置参数扩展为双引号引用的一个字符串，每个位置参数以<code>IFS</code>（通常默认为空格）变量分隔开。</p><p><code>$@</code>扩展为从<code>1</code>开始的位置参数列表。当被双引号包裹时（<code>&quot;$@&quot;</code>），将每个参数扩展为双引号引用的独立的字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> posit-param3</span></span><br><span class="line">print_params() &#123;</span><br><span class="line">  echo "\$1 = $1"</span><br><span class="line">  echo "\$2 = $2"</span><br><span class="line">  echo "\$3 = $3"</span><br><span class="line">  echo "\$4 = $4"</span><br><span class="line">&#125;</span><br><span class="line">pass_params() &#123;</span><br><span class="line">  echo '$*:'; print_params $*</span><br><span class="line">  echo '"$*":'; print_params "$*"</span><br><span class="line">  echo '$@:'; print_params $@</span><br><span class="line">  echo '"$@":'; print_params "$@"</span><br><span class="line">&#125;</span><br><span class="line">pass_params "word" "words with spaces"</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./posit-param3</span><br><span class="line"><span class="comment">#脚本输出</span></span><br><span class="line">$*:</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words</span><br><span class="line"><span class="variable">$3</span> = with</span><br><span class="line"><span class="variable">$4</span> = spaces</span><br><span class="line"></span><br><span class="line"><span class="string">"$*"</span>:</span><br><span class="line"><span class="variable">$1</span> = word words with spaces</span><br><span class="line"><span class="variable">$2</span> =</span><br><span class="line"><span class="variable">$3</span> =</span><br><span class="line"><span class="variable">$4</span> =</span><br><span class="line"></span><br><span class="line"><span class="variable">$@</span>:</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words</span><br><span class="line"><span class="variable">$3</span> = with</span><br><span class="line"><span class="variable">$4</span> = spaces</span><br><span class="line"></span><br><span class="line"><span class="string">"<span class="variable">$@</span>"</span>:</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words with spaces</span><br><span class="line"><span class="variable">$3</span> =</span><br><span class="line"><span class="variable">$4</span> =</span><br></pre></td></tr></table></figure><p>所以位置参数的扩展有<code>$*</code>、<code>&quot;$*&quot;</code>、<code>$@</code>、<code>&quot;$@&quot;</code>四种形式。通常情况下，<code>&quot;$@&quot;</code>会更符合我们的预期效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;shell&lt;/code&gt;提供了一组变量，用来存储传递给脚本或函数的参数&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux的几种压缩工具</title>
    <link href="2020/03/05/linux-compress/"/>
    <id>2020/03/05/linux-compress/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2021-07-09T10:16:22.076Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下<code>Linux</code>下的几种压缩及打包工具</p><a id="more"></a><h2 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-f 强制执行并覆盖掉原文件</span></span><br><span class="line"><span class="deletion">-b 压缩效率，9～16，默认值为16</span></span><br><span class="line"><span class="deletion">-d 解压缩，也可以使用uncompress命令</span></span><br><span class="line"><span class="deletion">-v 显示命令执行过程</span></span><br></pre></td></tr></table></figure><p>压缩生成<code>.Z</code>后缀名的文件，解压时也需要文件后缀为<code>.Z</code></p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-v 显示命令执行过程</span></span><br><span class="line"><span class="deletion">-q 不显示命令执行过程</span></span><br><span class="line"><span class="deletion">-r 递归处理目录</span></span><br></pre></td></tr></table></figure><p>使用<code>unzip</code>解压缩<code>zip</code>压缩的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip test.zip test.txt //把test.txt压缩为test.zip，可以接更多的文件或者文件夹</span><br><span class="line">$ unzip test.zip</span><br></pre></td></tr></table></figure><p>在压缩时若不指定后缀名，则生成的压缩文件默认为<code>.zip</code>，若指定了后缀名，则生成的文件名为所指定的，不会自动添加上<code>.zip</code></p><p>在使用<code>unzip</code>解压缩时，不需要文件的后缀名为<code>.zip</code>，只需要是<code>zip</code>压缩类型的文件</p><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-f 强制压缩文件</span></span><br><span class="line"><span class="deletion">-q 不显示警告信息</span></span><br><span class="line"><span class="deletion">-v 显示命令执行过程</span></span><br><span class="line"><span class="deletion">-d 解压，也可以使用uncompress命令</span></span><br><span class="line"><span class="deletion">-r 递归处理目录</span></span><br></pre></td></tr></table></figure><p>压缩后会生成以<code>.gz</code>为后缀的文件，并且在使用<code>gzip -d</code>或<code>gunzip</code>命令解压文件时，文件必须为以<code>.gz</code>为后缀并且是<code>gzip</code>压缩类型饿文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gzip ./*</span><br></pre></td></tr></table></figure><p>假设当前目录下有<code>test1 test2</code>两个文件，则这条命令会将这两个文件压缩为<code>test1.gz test2.gz</code></p><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c 将压缩与解压缩的结果输出到标准输出</span></span><br><span class="line"><span class="deletion">-f 默认情况下在压缩与解压缩时，若输出文件与现有文件同名，不会覆盖现有文件。若要覆盖，则可以使用此参数</span></span><br><span class="line"><span class="deletion">-d 解压缩，也可以使用bunzip2命令解压</span></span><br><span class="line"><span class="deletion">-v 显示压缩与解压缩的详细信息</span></span><br><span class="line"><span class="deletion">-k 默认情况下bzip2压缩或解压缩后会删除原文件，所想保留原文件，则可以使用此选项</span></span><br><span class="line"><span class="deletion">-z 强制执行压缩</span></span><br></pre></td></tr></table></figure><p>压缩后会生成以<code>.bz2</code>为后缀的文件，使用<code>bzip2 -d</code>或<code>bunzip2</code>命令解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//假设当前目录有两个文件名为 data1 data2</span><br><span class="line"></span><br><span class="line">$ bzip2 ./*//经过压缩生成 data1.bz2 data2.bz2</span><br><span class="line">$ bzip2 -d data1.bz2//data1.bz2被解压为data1</span><br><span class="line"></span><br><span class="line">$ mv data2.bz2 data2    //这里将另一个压缩文件重命名去除.bz2后缀</span><br><span class="line">$ bzip2 -d data2//由于不是.bz2后缀，这里猜测不到原始文件名，默认解压后文件名为data2.out</span><br></pre></td></tr></table></figure><p>如上述命令，解压<code>bzip2</code>压缩类型文件不强制要求后缀为<code>.bz2</code>。解压时，若后缀名为<code>.bz2</code>，则解压后文件名为去除<code>.bz2</code>的文件名，若后缀不是<code>.bz2</code>，则解压后文件名为原文件名加上<code>.out</code>后缀</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c 打包文件和目录</span></span><br><span class="line"><span class="deletion">-C 在指定的目录解压缩</span></span><br><span class="line"><span class="deletion">-x 还原文件</span></span><br><span class="line"><span class="deletion">-z 在打包的同时使用gzip进行压缩或解压（与-c同时使用时是压缩，与-x同时使用时是解压）</span></span><br><span class="line"><span class="deletion">-Z 在打包的同时使用compress进行压缩或解压（与-c同时使用时是压缩，与-x同时使用时是解压）</span></span><br><span class="line"><span class="deletion">-j 在打包的同时使用bzip2进行压缩或解压（与-c同时使用时是压缩，与-x同时使用时是解压）</span></span><br><span class="line"><span class="deletion">-v 显示命令执行过程</span></span><br><span class="line"><span class="deletion">-f 指定文件名</span></span><br></pre></td></tr></table></figure><p><code>compress</code>、<code>zip</code>、<code>gzip</code>、<code>bzip2</code>命令是对文件进行压缩。而<code>tar</code>命令是对文件或目录进行打包操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf test.tar ./*//这里将当前目录下的所有文件和目录打包为test.tar文件</span><br></pre></td></tr></table></figure><p>这里可以任意指定文件名和后缀，并不需要强制指定<code>.tar</code>后缀</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf test.tar.gz ./*//这里将当前目录下的所有文件和目录打包为test.tar文件后又进行了gzip压缩</span><br></pre></td></tr></table></figure><p>这里的文件名也是可以任意指定的，处理完成后是<code>gzip</code>压缩的文件。</p><p>如果这里命名的文件名不是以<code>.gz</code>为后缀，如<code>test</code>，若要直接进行<code>gunzip</code>解压之前必须要将文件的后缀改为<code>test.gz</code>，解压后文件是名为<code>test</code>的<code>tar</code>归档文件，接下来可以使用<code>tar -xvf test</code> 来恢复。</p><p>上述两步操作也可以用<code>tar -zxvf test</code>一步操作来完成</p><p>使用<code>-Z</code>、<code>-j</code>选项的命令与之类似</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下&lt;code&gt;Linux&lt;/code&gt;下的几种压缩及打包工具&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>find命令使用笔记</title>
    <link href="2020/03/04/linux-find/"/>
    <id>2020/03/04/linux-find/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2021-07-09T10:24:44.742Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [查找路径] [选项]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="name选项"><a href="#name选项" class="headerlink" title="-name选项"></a>-name选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure><p><code>-name</code>后可以是确切的带查询名称或者模式字符串</p><p><code>-iname</code>可以忽略大小写</p><p><code>-regex</code>是匹配整个路径</p><h2 id="size选项"><a href="#size选项" class="headerlink" title="-size选项"></a>-size选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -size 1033c</span><br></pre></td></tr></table></figure><p>查找指定大小的文件，若不指定单位则默认的单位是<code>b</code></p><div class="table-container"><table><thead><tr><th>单位符号</th><th>说明</th></tr></thead><tbody><tr><td>c</td><td>bytes</td></tr><tr><td>w</td><td>two-byte words</td></tr><tr><td>b</td><td>512-byte blocks</td></tr><tr><td>k</td><td>Kilobytes (units of 1024 bytes)</td></tr><tr><td>M</td><td>Megabytes (units of 1048576 bytes)</td></tr><tr><td>G</td><td>Gigabytes (units of 1073741824 bytes)</td></tr><tr><td></td></tr></tbody></table></div><h2 id="type选项"><a href="#type选项" class="headerlink" title="-type选项"></a>-type选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure><p>根据指定的类型查询目录或文件</p><div class="table-container"><table><thead><tr><th>类型标识</th><th>说明</th></tr></thead><tbody><tr><td>f</td><td>普通文件</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>l</td><td>链接</td></tr><tr><td>b</td><td>块设备</td></tr><tr><td>c</td><td>字符设备</td></tr><tr><td>p</td><td>Fifo管道文件</td></tr><tr><td>s</td><td>套接字</td></tr></tbody></table></div><h2 id="user选项"><a href="#user选项" class="headerlink" title="-user选项"></a>-user选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -user test1</span><br></pre></td></tr></table></figure><p>查找所属用户为指定用户的文件或目录</p><p><code>-uid</code>选项查找符合指定的<code>uid</code>的文件或目录</p><h2 id="group选项"><a href="#group选项" class="headerlink" title="-group选项"></a>-group选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -group test2</span><br></pre></td></tr></table></figure><p>查找所属组为指定组的问价或目录</p><p><code>-gid</code>选项查找符合指定的<code>gid</code>的文件或目录</p><h2 id="exec选项"><a href="#exec选项" class="headerlink" title="-exec选项"></a>-exec选项</h2><p>对找到的文档执行特定的命令</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;find [查找路径] [选项]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>docker build 的上下文目录</title>
    <link href="2020/03/02/dockerfile/"/>
    <id>2020/03/02/dockerfile/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2021-07-09T10:17:27.703Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span>:1 .</span><br></pre></td></tr></table></figure><p>这条命令最后的<code>.</code>指当前目录，<code>docker</code>引擎会解析目录下名为<code>Dockerfile</code>的文件并执行其中的命令。也可以指定特定文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span>:1 -f &lt;filepath&gt; .</span><br></pre></td></tr></table></figure><p>但其实这里的<code>.</code>实际上指的是<code>docker</code>引擎执行构建命令时的上下文目录。</p><p>执行这条命令后首先会将此指定的目录下的所有内容打包发送给<code>docker</code>引擎，也就是说这个上下文目录与<code>Dockerfile</code>目录可以分开指定。</p><p>为了避免发送不必要的文件，可以使用<code>.dockerignore</code>来添加忽略文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
    
    
      <category term="docker" scheme="//sunxingboo.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="2020/02/27/js-closure/"/>
    <id>2020/02/27/js-closure/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2021-07-09T10:24:16.724Z</updated>
    
    <content type="html"><![CDATA[<p>闭包就是获取其他函数内部变量的函数。</p><a id="more"></a><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">console</span>.log(n);  <span class="comment">// ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure><p>函数外部无法获取函数内部变量，并且函数执行完毕后变量已被销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = f1();</span><br><span class="line"><span class="built_in">console</span>.log(res()); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>在函数内部再定义一个函数，并作为返回值，此匿名函数依赖于<code>f1</code>，所以<code>f1</code>执行完毕后并不会被销毁回收，因此可以通过调用返回的匿名函数来获取<code>f1</code>内部变量<code>n</code>。</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>函数内部的<code>this</code>关键字指向的是调用此函数的对象。定义时并没有生效，而是在运行时生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'sun'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'bo'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//这里指向顶层window对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1()); <span class="comment">// ‘sun’</span></span><br></pre></td></tr></table></figure><h2 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//这里的 this 在运行时指向的是 getNameFunc 函数 </span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如上代码由于运行时<code>this</code>指向<code>getNameFunc</code>函数，此函数内没有<code>name</code>属性定义，因此返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">//这里的 this 在运行指向的是 object，赋值给 that 后，在返回的闭包函数中指向的依然是 object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// "My Object"</span></span><br></pre></td></tr></table></figure><p>通过一层转化暂存<code>this</code>指向，返回的闭包函数可以获取到<code>object</code>的<code>name</code>属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包就是获取其他函数内部变量的函数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="//sunxingboo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="2020/02/26/heap-sort/"/>
    <id>2020/02/26/heap-sort/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2021-07-09T10:22:07.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h2><p>堆排序所利用的数据结构就是<strong>完全二叉树</strong>，其定义为除了最后一层外，其他各层的节点数都达到最大，并且最后一层的节点都连续集中在最左边。如果最后一层的节点数也达到最大，那么次完全二叉树也是满二叉树。</p><pre class="mermaid">graph TB    1 --> 2    1 --> 3    2 --> 4    2 --> 5    3 --> 6    3 --> 7    4 --> 8    4 --> 9</pre><a id="more"></a><p>而堆的概念是建立在完全二叉树之上的，每个节点的值均<em>大于</em>其左右子节点值的完全二叉树为<strong>大顶堆</strong>，而每个节点的值均<em>小于</em>其左右子节点值的完全二egq叉树为<strong>小顶堆</strong>。</p><pre class="mermaid">graph TB    subgraph 大顶堆    5 --> 3    5 --> 4    3 --> 1    3 --> 2  end  subgraph 小顶堆      6 --> 7      6 --> 8      7 --> 9      7 --> 10  end</pre><h2 id="堆排序算法思路"><a href="#堆排序算法思路" class="headerlink" title="堆排序算法思路"></a>堆排序算法思路</h2><p>假设待排序样本为<code>[4, 7, 5, 3, 1, 0, 2]</code></p><ul><li><p>将样本构建为大顶堆</p></li><li><p>将根结点（堆顶）与最后一个节点交换</p></li><li><p>重新调整堆</p></li><li><p>重复步骤 2、3</p></li></ul><h2 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  length := <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="comment">//初始化构建大顶堆</span></span><br><span class="line">  buildHeap(arr, length)</span><br><span class="line">  <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="comment">//堆顶与尾部交换，交换之后尾部就有序了，length - 1缩短待处理样本</span></span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    length--</span><br><span class="line">    <span class="comment">//交换之后大顶堆已被破坏，重新调整</span></span><br><span class="line">    heapify(arr, <span class="number">0</span>, length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建大顶堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(arr []<span class="keyword">int</span>, length <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//找到最后一个节点，依次向前遍历</span></span><br><span class="line">  <span class="keyword">for</span> i := length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    heapify(arr, i, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arr 样本</span></span><br><span class="line"><span class="comment"> * node 待调整的节点（数组索引）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>, node <span class="keyword">int</span>, length <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//左右子节点索引</span></span><br><span class="line">  left := node * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  right := node * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">  largest := node</span><br><span class="line">  <span class="keyword">if</span> left &lt; length &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> right &lt; length &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> largest != node &#123;</span><br><span class="line">    swap(arr, node, largest)</span><br><span class="line">    heapify(arr, largest, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(arr []<span class="keyword">int</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆的数据结构&quot;&gt;&lt;a href=&quot;#堆的数据结构&quot; class=&quot;headerlink&quot; title=&quot;堆的数据结构&quot;&gt;&lt;/a&gt;堆的数据结构&lt;/h2&gt;&lt;p&gt;堆排序所利用的数据结构就是&lt;strong&gt;完全二叉树&lt;/strong&gt;，其定义为除了最后一层外，其他各层的节点数都达到最大，并且最后一层的节点都连续集中在最左边。如果最后一层的节点数也达到最大，那么次完全二叉树也是满二叉树。&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph TB
    1 --&gt; 2
    1 --&gt; 3
    2 --&gt; 4
    2 --&gt; 5
    3 --&gt; 6
    3 --&gt; 7
    4 --&gt; 8
    4 --&gt; 9&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="//sunxingboo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="//sunxingboo.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP 三次握手</title>
    <link href="2020/01/16/tcp-three-shake/"/>
    <id>2020/01/16/tcp-three-shake/</id>
    <published>2020-01-15T16:00:00.000Z</published>
    <updated>2021-07-09T10:29:52.795Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">sequenceDiagram    participant C as Client    participant S as Server    C->>S: relative_seq=0, raw_seq=n1    S->>C: relative_seq=0, raw_seq=n2, relative_ack=1, raw_ack=n1+1    C->>S: relative_seq=1, raw_seq=raw_ack, relative_ack=1, raw_ack=n2+1</pre><a id="more"></a><p>在浏览器内发起网址请求，不考虑网络层通信细节，只对于 <code>TCP</code> 进行三次握手建立链接的过程，抓包具体分析如下</p><p><code>seq</code>与<code>ack</code>均分为<code>relative</code>和<code>raw</code>，即相对值与实际值。</p><p><em>第一次握手</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: 55879, Dst Port: 80, Seq: 0, Len: 0</span><br><span class="line">    Source Port: 55879</span><br><span class="line">    Destination Port: 80</span><br><span class="line"><span class="section">    [Stream index: 49]</span></span><br><span class="line"><span class="section">    [TCP Segment Len: 0]</span></span><br><span class="line">    Sequence number: 0    (relative sequence number)</span><br><span class="line">    Sequence number (raw): 3271402248</span><br><span class="line"><span class="section">    [Next sequence number: 1    (relative sequence number)]</span></span><br><span class="line">    Acknowledgment number: 0</span><br><span class="line">    Acknowledgment number (raw): 0</span><br><span class="line">    1011 .... = Header Length: 44 bytes (11)</span><br><span class="line">    Flags: 0x002 (SYN)</span><br><span class="line">        000. .... .... = Reserved: Not set</span><br><span class="line">        ...0 .... .... = Nonce: Not set</span><br><span class="line">        .... 0... .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... .0.. .... = ECN-Echo: Not set</span><br><span class="line">        .... ..0. .... = Urgent: Not set</span><br><span class="line">        .... ...0 .... = Acknowledgment: Not set</span><br><span class="line">        .... .... 0... = Push: Not set</span><br><span class="line">        .... .... .0.. = Reset: Not set</span><br><span class="line">        .... .... ..1. = Syn: Set</span><br><span class="line"><span class="section">            [Expert Info (Chat/Sequence): Connection establish request (SYN): server port 80]</span></span><br><span class="line">        .... .... ...0 = Fin: Not set</span><br><span class="line"><span class="section">        [TCP Flags: ··········S·]</span></span><br><span class="line">   </span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>客户端请求，相对<code>seq</code>值为 0，实际为 3271402248。<code>ack</code> 值为 0</p><p><code>Flags</code>中设置 <code>Syn</code>。</p><p><em>第二次握手</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 55879, Seq: 0, Ack: 1, Len: 0</span><br><span class="line">    Source Port: 80</span><br><span class="line">    Destination Port: 55879</span><br><span class="line"><span class="section">    [Stream index: 49]</span></span><br><span class="line"><span class="section">    [TCP Segment Len: 0]</span></span><br><span class="line">    Sequence number: 0    (relative sequence number)</span><br><span class="line">    Sequence number (raw): 2899824743</span><br><span class="line"><span class="section">    [Next sequence number: 1    (relative sequence number)]</span></span><br><span class="line">    Acknowledgment number: 1    (relative ack number)</span><br><span class="line">    Acknowledgment number (raw): 3271402249</span><br><span class="line">    1000 .... = Header Length: 32 bytes (8)</span><br><span class="line">    Flags: 0x012 (SYN, ACK)</span><br><span class="line">        000. .... .... = Reserved: Not set</span><br><span class="line">        ...0 .... .... = Nonce: Not set</span><br><span class="line">        .... 0... .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... .0.. .... = ECN-Echo: Not set</span><br><span class="line">        .... ..0. .... = Urgent: Not set</span><br><span class="line">        .... ...1 .... = Acknowledgment: Set</span><br><span class="line">        .... .... 0... = Push: Not set</span><br><span class="line">        .... .... .0.. = Reset: Not set</span><br><span class="line">        .... .... ..1. = Syn: Set</span><br><span class="line"><span class="section">            [Expert Info (Chat/Sequence): Connection establish acknowledge (SYN+ACK): server port 80]</span></span><br><span class="line">        .... .... ...0 = Fin: Not set</span><br><span class="line"><span class="section">        [TCP Flags: ·······A··S·]</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>服务端应答，<code>ack</code>值为上一步的<code>seq</code>值<code>+1</code>，所以相对<code>ack</code>值为 <code>0+1=1</code>，<code>ack</code>值为<code>3271402248+1=3271402249</code>。相对<code>seq</code>值为 0，实际<code>seq</code>值为 2899824743。</p><p><code>Flags</code>中设置 <code>Syn</code>和<code>Acknowledgment</code>。</p><p><em>第三次握手</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: 55879, Dst Port: 80, Seq: 1, Ack: 1, Len: 0</span><br><span class="line">    Source Port: 55879</span><br><span class="line">    Destination Port: 80</span><br><span class="line"><span class="section">    [Stream index: 49]</span></span><br><span class="line"><span class="section">    [TCP Segment Len: 0]</span></span><br><span class="line">    Sequence number: 1    (relative sequence number)</span><br><span class="line">    Sequence number (raw): 3271402249</span><br><span class="line"><span class="section">    [Next sequence number: 1    (relative sequence number)]</span></span><br><span class="line">    Acknowledgment number: 1    (relative ack number)</span><br><span class="line">    Acknowledgment number (raw): 2899824744</span><br><span class="line">    0101 .... = Header Length: 20 bytes (5)</span><br><span class="line">    Flags: 0x010 (ACK)</span><br><span class="line">        000. .... .... = Reserved: Not set</span><br><span class="line">        ...0 .... .... = Nonce: Not set</span><br><span class="line">        .... 0... .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... .0.. .... = ECN-Echo: Not set</span><br><span class="line">        .... ..0. .... = Urgent: Not set</span><br><span class="line">        .... ...1 .... = Acknowledgment: Set</span><br><span class="line">        .... .... 0... = Push: Not set</span><br><span class="line">        .... .... .0.. = Reset: Not set</span><br><span class="line">        .... .... ..0. = Syn: Not set</span><br><span class="line">        .... .... ...0 = Fin: Not set</span><br><span class="line"><span class="section">        [TCP Flags: ·······A····]</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>客户端应答，相对<code>seq</code>值为 1，实际<code>seq</code>值为上一步服务端响应的实际<code>ack</code>值，相对<code>ack</code>值为 1，实际<code>ack</code>值为上一步服务端响应的实际<code>seq</code>值<code>+1</code>。</p><p><code>Flags</code>中设置 <code>Syn</code>和<code>Acknowledgment</code>。</p><p>至此，<code>TCP</code>链接建立完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre class=&quot;mermaid&quot;&gt;sequenceDiagram
    participant C as Client
    participant S as Server
    C-&gt;&gt;S: relative_seq=0, raw_seq=n1
    S-&gt;&gt;C: relative_seq=0, raw_seq=n2, relative_ack=1, raw_ack=n1+1
    C-&gt;&gt;S: relative_seq=1, raw_seq=raw_ack, relative_ack=1, raw_ack=n2+1&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="TCP" scheme="//sunxingboo.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>HSTS 安全策略及 HTTP 3XX状态码</title>
    <link href="2020/01/09/hsts/"/>
    <id>2020/01/09/hsts/</id>
    <published>2020-01-08T16:00:00.000Z</published>
    <updated>2021-07-09T10:23:17.610Z</updated>
    
    <content type="html"><![CDATA[<p>工作测试时遇到 <code>HSTS</code> 导致的重定向问题，查阅资料做如下整理。</p><a id="more"></a><h2 id="1-HSTS"><a href="#1-HSTS" class="headerlink" title="1. HSTS"></a>1. HSTS</h2><h3 id="1-1-概念与作用"><a href="#1-1-概念与作用" class="headerlink" title="1.1. 概念与作用"></a>1.1. 概念与作用</h3><blockquote><p>HSTS 是 HTTP Strict Transport Security 的缩写，即：“ HTTP 严格传输安全”</p></blockquote><p>它的作用是强制客户端使用 HTTPS 与服务器建立连接。</p><h3 id="1-2-HTTPS-连接建立过程"><a href="#1-2-HTTPS-连接建立过程" class="headerlink" title="1.2. HTTPS 连接建立过程"></a>1.2. HTTPS 连接建立过程</h3><p>对于使用 HTTPS 的服务器，客户端建立连接的过程大致如下，用户第一次直接输入网址发起 HTTP 请求，服务器给予用户重定向响应，客户端收到响应发起 HTTPS 请求。</p><pre class="mermaid">sequenceDiagram    participant C as 浏览器    participant S as 服务器    C->>S: http://codernote.top    S->>C: 重定向响应 https://www.codernote.top:443    C->>S: https://www.codernote.top:443    S->>C: 200 OK</pre><h3 id="1-3-缺陷"><a href="#1-3-缺陷" class="headerlink" title="1.3. 缺陷"></a>1.3. 缺陷</h3><p>可以很容易发现这一 HTTPS 连接的建立过程存在明显的缺陷，就是存在一次明文通信的 HTTP 请求，容易被中间人劫持，这样就导致 HTTPS 失去了作用。</p><pre class="mermaid">sequenceDiagram    participant C as 浏览器    participant M as 中间人    participant S2 as 邪恶的网站    participant S1 as codernote.top    C->>M: http://codernote.top    M->>S2: 被劫持    S2->>M: 200 OK    M->>C: 200 OK</pre><h3 id="1-4-解决办法-HSTS"><a href="#1-4-解决办法-HSTS" class="headerlink" title="1.4. 解决办法 HSTS"></a>1.4. 解决办法 HSTS</h3><p><code>HSTS</code> 就是为了解决这一缺陷。浏览器自动将 <code>HTTP</code> 转换为 <code>HTTPS</code> 请求。实现这一转换过程就要基于服务器的 <code>HSTS</code> 响应头，<strong>在第一次成功的请求后获取到响应头，此后在过期时间内，对于该域名的请求都将强制使用<code>HSTS</code></strong>。</p><pre class="mermaid">sequenceDiagram    participant C as 浏览器    participant S as 服务器    C->>C: http://codernote.top    C->>S: https://www.codernote.top:443    S->>C: 200 OK</pre><h3 id="1-5-HSTS-响应头"><a href="#1-5-HSTS-响应头" class="headerlink" title="1.5. HSTS 响应头"></a>1.5. HSTS 响应头</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload]</span><br></pre></td></tr></table></figure><p>它由三部分组成</p><ul><li><code>max-age</code> : 必选项，过期时间</li><li><code>includeSubDomains</code> : 可选，当前域名及子域名域名均开启 <code>HSTS</code></li><li><code>preload</code> : 可选，域名申请加入浏览器内置列表时必须开启此选项</li></ul><h3 id="1-6-依然存在的缺陷"><a href="#1-6-依然存在的缺陷" class="headerlink" title="1.6. 依然存在的缺陷"></a>1.6. 依然存在的缺陷</h3><p>但是这种机制下仍然存在漏洞，就是要有一次对目标服务器成功的请求，这一才能获取到包含 <code>HSTS</code> 响应头的响应，也就是说仍然需要经历一次由 <code>HTTP</code> 到 <code>HTTPS</code> 的重定向，也就仍然存在被劫持的风险。</p><p>浏览器 <code>preload list</code> 用来解决这一缺陷，申请加域名添加至浏览器的  <code>preload list</code> 后则所有对该域名的请求都将转换为 <code>HTTPS</code>。</p><h2 id="2-HTTP-3XX-状态码"><a href="#2-HTTP-3XX-状态码" class="headerlink" title="2. HTTP 3XX 状态码"></a>2. HTTP 3XX 状态码</h2><div class="table-container"><table><thead><tr><th>状态码</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td></td></tr><tr><td>308</td><td>Permanent Redirect</td><td></td></tr><tr><td>302</td><td>Found</td><td>临时重定向 POST 不限制具体实现</td></tr><tr><td>303</td><td>See Other</td><td>POST 转为 GET</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>保持 POST</td></tr><tr><td>304</td><td>Not Modified</td><td>无变更</td></tr><tr><td>305</td><td>Use Proxy</td><td>必须使用指定的代理访问</td></tr><tr><td>306</td><td>Switch Proxy</td><td>已废弃</td></tr></tbody></table></div><h3 id="2-1-302、303、307-状态码"><a href="#2-1-302、303、307-状态码" class="headerlink" title="2.1. 302、303、307 状态码"></a>2.1. 302、303、307 状态码</h3><p><code>HTTP 1.0</code> 定义 302 状态码，临时重定向，此时说明原 <code>URI</code> 地址依然可用，应该保持。浏览器重定向至响应头中 <code>Location</code> 指定的地址，规定对 <code>POST</code> 请求重定向是不能改变请求方法，但是各浏览器的实现中并未全部遵守此规定，有的浏览器会将原本 <code>POST</code> 请求的重定向转换为 <code>GET</code>，而有的浏览器依然保持原请求方法。</p><p>在 <code>HTTP 1.1</code> 中修改了规范</p><ul><li>302 状态码对 <code>POST</code> 的重定向不再限制，可以转为 <code>GET</code> 也可以保持 <code>POST</code> </li><li>增加 303 状态码，<code>POST</code> 的重定向会转为 <code>GET</code></li><li>增加 307 状态码，<code>POST</code> 的重定向会保持 <code>POST</code></li></ul><p>也就是说 303、307 状态码是对 302 的补充，保持 302 兼容老版本。</p><h3 id="2-2-301、308-状态码"><a href="#2-2-301、308-状态码" class="headerlink" title="2.2. 301、308 状态码"></a>2.2. 301、308 状态码</h3><p>与 302 类似，308 是对 301 的补充，均为永久重定向，但是 301 的实现如 302 , 有时 <code>POST</code> 会被转换为 <code>GET</code>，而 308 不会进行转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作测试时遇到 &lt;code&gt;HSTS&lt;/code&gt; 导致的重定向问题，查阅资料做如下整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="HTTP" scheme="//sunxingboo.github.io/tags/HTTP/"/>
    
      <category term="安全" scheme="//sunxingboo.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP `??` 与 `?:` 操作符的区别</title>
    <link href="2020/01/07/php-operator/"/>
    <id>2020/01/07/php-operator/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2021-07-09T10:26:04.854Z</updated>
    
    <content type="html"><![CDATA[<p><code>??</code> 操作符是 PHP 7 引入的特性，它的使用方式与 <code>?:</code> 的区别总结如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $str = <span class="string">""</span>;</span><br><span class="line">  $arr = [<span class="string">"b"</span> =&gt; <span class="number">0</span>, <span class="string">"c"</span> =&gt; <span class="keyword">null</span>];</span><br><span class="line">  $test1 = $str ?? <span class="string">"test1"</span>;</span><br><span class="line">  $test2 = $str ?: <span class="string">"test2"</span>;</span><br><span class="line">  $test3 = $arr[<span class="string">"a"</span>] ?? <span class="string">"test3"</span>;</span><br><span class="line">  $test4 = $arr[<span class="string">"b"</span>] ?? <span class="string">"test4"</span>;</span><br><span class="line">  $test5 = $arr[<span class="string">"c"</span>] ?? <span class="string">"test5"</span>;</span><br><span class="line">  var_dump($test1, $test2, $test3, $test4, $test5);</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">string</span><span class="params">(<span class="number">0</span>)</span></span> <span class="string">""</span></span><br><span class="line"><span class="function"><span class="title">string</span><span class="params">(<span class="number">5</span>)</span></span> <span class="string">"test2"</span></span><br><span class="line"><span class="function"><span class="title">string</span><span class="params">(<span class="number">5</span>)</span></span> <span class="string">"test3"</span></span><br><span class="line"><span class="function"><span class="title">int</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">string</span><span class="params">(<span class="number">5</span>)</span></span> <span class="string">"test5"</span></span><br></pre></td></tr></table></figure><p><code>??</code> 的判断形式相当于 <code>isset</code> 函数，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$test1 = $str ?? "test";</span></span><br><span class="line">$test1 = <span class="keyword">isset</span>($str) ? $str : <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p><code>isset</code> 函数判断结果为 <code>false</code> 的几种情况：</p><ul><li>变量未定义</li><li>变量值为 <code>null</code>（也就是说值为 <code>0</code> <code>&quot;0&quot;</code>都会返回 <code>true</code>）</li><li>检查字符串的<strong>非数字</strong>偏移量</li></ul><p>而 <code>?:</code> 的判断相当于 <code>empty</code> 函数，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$test2 = $str ?: "test";</span></span><br><span class="line">$test2 = !<span class="keyword">empty</span>($str) ? $str : <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p><code>empty</code> 函数判断结果为 <code>false</code> 的几种情况：</p><ul><li>空字符串 <code>&quot;&quot;</code></li><li>整数 <code>0</code></li><li>浮点数 <code>0.0</code></li><li>字符串 <code>&quot;0&quot;</code></li><li><code>null</code></li><li><code>false</code></li><li>空数组 <code>[]</code></li><li>声明了但是没有值的变量</li></ul><p><code>isset</code> 和 <code>empty</code> 函数官方文档：</p><blockquote><p>isset函数文档：<a href="https://www.php.net/manual/zh/function.isset.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.isset.php</a></p><p>empty函数文档：<a href="https://www.php.net/manual/zh/function.empty.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.empty.php</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;??&lt;/code&gt; 操作符是 PHP 7 引入的特性，它的使用方式与 &lt;code&gt;?:&lt;/code&gt; 的区别总结如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $str = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $arr = [&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $test1 = $str ?? &lt;span class=&quot;string&quot;&gt;&quot;test1&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $test2 = $str ?: &lt;span class=&quot;string&quot;&gt;&quot;test2&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $test3 = $arr[&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;] ?? &lt;span class=&quot;string&quot;&gt;&quot;test3&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $test4 = $arr[&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;] ?? &lt;span class=&quot;string&quot;&gt;&quot;test4&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  $test5 = $arr[&lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;] ?? &lt;span class=&quot;string&quot;&gt;&quot;test5&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var_dump($test1, $test2, $test3, $test4, $test5);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="PHP" scheme="//sunxingboo.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>set 命令及常用参数</title>
    <link href="2019/12/28/linux-set/"/>
    <id>2019/12/28/linux-set/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2021-07-09T10:28:18.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>set命令</strong>作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号”+”和”-“的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用<a href="http://man.linuxde.net/declare" target="_blank" rel="noopener">declare</a>命令以<code>变量名=值</code>的格式进行定义即可。</p></blockquote><a id="more"></a><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="u-参数"><a href="#u-参数" class="headerlink" title="-u 参数"></a>-u 参数</h3><p>执行时遇到未定义的变量 <code>bash</code> 默认忽略，设置 <code>-u</code> 参数当执行使用到未定义的变量时显示错误信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo $a</span><br><span class="line">echo "test"</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>设置 <code>-u</code> 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -u</span><br><span class="line"></span><br><span class="line">echo $a</span><br><span class="line">echo "test"</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line">set.sh:行4: a: 未绑定变量</span><br></pre></td></tr></table></figure><p>等效命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -o nounset</span><br></pre></td></tr></table></figure><h3 id="x-参数"><a href="#x-参数" class="headerlink" title="-x 参数"></a>-x 参数</h3><p>脚本运行时，打印出输出很多时候不能确定是由哪条命令输出的，设置 <code>-x</code> 参数在执行命令后会先显示该命令及参数，然后打印输出，有利于调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "a"</span><br><span class="line">echo "test"</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line">a</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>设置 <code>-x</code> 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">echo "a"</span><br><span class="line">echo "test"</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line">+ <span class="built_in">echo</span> a</span><br><span class="line">a</span><br><span class="line">+ <span class="built_in">echo</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>等效命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -o xtrace</span><br></pre></td></tr></table></figure><h3 id="e-参数"><a href="#e-参数" class="headerlink" title="-e 参数"></a>-e 参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">t</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line">set.sh:行3: t: 未找到命令</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>以上脚本虽然在第三行 <code>t</code> 命令不存在，但是报错后继续向下执行。为错误的叠加有时候需要发生错误时推出脚本。此时设置 <code>-e</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">t</span><br><span class="line">echo test</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bash set.sh</span><br><span class="line">set.sh:行4: t: 未找到命令</span><br></pre></td></tr></table></figure><p>此时在报错之后直接退出不会向下执行。</p><p>也可以在给一个代码段开启 <code>-e</code> 参数，执行完改代码段后再取出改参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">t</span><br><span class="line">echo test</span><br><span class="line"></span><br><span class="line">set +e</span><br></pre></td></tr></table></figure><p>等效命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -o errexit</span><br></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-a：标示已修改的变量，以供输出至环境变量。</span><br><span class="line">-b：使被中止的后台程序立刻回报执行状态。</span><br><span class="line">-C：转向所产生的文件无法覆盖已存在的文件。</span><br><span class="line">-d：Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。</span><br><span class="line">-f：取消使用通配符。</span><br><span class="line">-h：自动记录函数的所在位置。</span><br><span class="line">-H Shell：可利用"!"加&lt;指令编号&gt;的方式来执行history中记录的指令。</span><br><span class="line">-k：指令所给的参数都会被视为此指令的环境变量。</span><br><span class="line">-l：记录for循环的变量名称。</span><br><span class="line">-m：使用监视模式。</span><br><span class="line">-n：只读取指令，而不实际执行。</span><br><span class="line">-p：启动优先顺序模式。</span><br><span class="line">-P：启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。</span><br><span class="line">-t：执行完随后的指令，即退出shell。</span><br><span class="line">-v：显示shell所读取的输入值。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;set命令&lt;/strong&gt;作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号”+”和”-“的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用&lt;a href=&quot;http://man.linuxde.net/declare&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;declare&lt;/a&gt;命令以&lt;code&gt;变量名=值&lt;/code&gt;的格式进行定义即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客部署到云服务器总结</title>
    <link href="2019/12/21/hexo-to-host/"/>
    <id>2019/12/21/hexo-to-host/</id>
    <published>2019-12-20T16:00:00.000Z</published>
    <updated>2021-07-09T10:22:45.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><ul><li><code>rsync</code></li><li><code>git</code></li></ul><a id="more"></a><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nginx git</span><br><span class="line">$ mkdir /data/www/hexo</span><br><span class="line">$ vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">  <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">  <span class="attribute">server_name</span>  codernote.top;</span><br><span class="line">  <span class="attribute">root</span>         /data/www/hexo;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为登录账户创建 <code>authorized_keys</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#每行一个key</span></span><br></pre></td></tr></table></figure><h2 id="rsync-部署"><a href="#rsync-部署" class="headerlink" title="rsync 部署"></a>rsync 部署</h2><p><em>推荐使用这种方式</em></p><p>安装依赖工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-rsync --save</span><br></pre></td></tr></table></figure><p>修改配置 <code>_config.yml</code>，添加 <code>deploy</code>，这里同时部署到 <code>github</code> 和云服务器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">git@github.com:sunxingboo/sunxingboo.github.io</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">rsync</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">&lt;域名或ip&gt;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&lt;登录用户&gt;</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">&lt;部署目录&gt;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;ssh端口&gt;</span></span><br><span class="line">    <span class="attr">delete:</span> <span class="string">&lt;部署前先清空目录&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-部署"><a href="#git-部署" class="headerlink" title="git 部署"></a>git 部署</h2><p>创建仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /data/GitLibrary &amp;&amp; <span class="built_in">cd</span> /data/GitLibrary</span><br><span class="line">$ git init --bare hexo.git</span><br></pre></td></tr></table></figure><p>创建钩子，在仓库更新时同步更新到博客目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /data/GitLibrary/hexo.git/hooks/post-receive</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/data/www/hexo --git-dir=/data/GitLibrary/hexo.git checkout -f</span><br></pre></td></tr></table></figure><p>开放可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x /data/GitLibrary/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>修改 <code>_config.yml</code> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">user@IP:/data/GitLibrary/hexo.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这里如果出于安全原因修改了 <code>ssh</code> 端口，则配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">ssh://user@IP:port/data/GitLibrary/hexo.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;部署方式&quot;&gt;&lt;a href=&quot;#部署方式&quot; class=&quot;headerlink&quot; title=&quot;部署方式&quot;&gt;&lt;/a&gt;部署方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="//sunxingboo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>xargs 命令及常用参数</title>
    <link href="2019/12/20/xargs/"/>
    <id>2019/12/20/xargs/</id>
    <published>2019-12-20T09:13:00.000Z</published>
    <updated>2021-07-09T10:32:44.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>xargs - build and execute command lines from standard input</p></blockquote><a id="more"></a><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><p>有的命令可以将标准输入作为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"test"</span> | grep t</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>但是很多命令不接受标准输入作为参数，如 <code>echo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"test"</span> | <span class="built_in">echo</span></span><br><span class="line">// 不会有输出</span><br></pre></td></tr></table></figure><h2 id="xargs-的作用"><a href="#xargs-的作用" class="headerlink" title="xargs 的作用"></a>xargs 的作用</h2><p><code>xargs</code> 可以为命令接受标准输入并转化为参数列表，它的默认命令就是 <code>echo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"test"</span> | xargs </span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>上面的 <code>xargs</code> 命令将标准输入转换为命令行参数传给默认命令 <code>echo</code></p><p>命令语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xargs [-options] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><h2 id="d-参数设置分隔符"><a href="#d-参数设置分隔符" class="headerlink" title="-d 参数设置分隔符"></a>-d 参数设置分隔符</h2><p><code>xargs</code> 默认将空格和换行符作为分隔符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"ababa"</span> | xargs -d <span class="string">"a"</span></span><br><span class="line">b b</span><br></pre></td></tr></table></figure><h2 id="p-与-t-参数"><a href="#p-与-t-参数" class="headerlink" title="-p 与 -t 参数"></a>-p 与 -t 参数</h2><p><code>-p</code> 在命令执行前打印命令，并询问用户是否要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"a b c"</span> | xargs -p</span><br><span class="line"><span class="built_in">echo</span> a b c ?...</span><br></pre></td></tr></table></figure><p>命令将打印如上结果，用户输入 <code>y/Y</code> 才会执行</p><p><code>-t</code> 参数是在打印将要执行的命令之后立即执行该命令，不需要用户确认</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"a b c"</span> | xargs -t mkdir</span><br><span class="line">mkdir a b c</span><br></pre></td></tr></table></figure><p>执行上述命令创建三个目录</p><h2 id="L-参数"><a href="#L-参数" class="headerlink" title="-L 参数"></a>-L 参数</h2><p>标准输入包含多行时，<code>-L</code> 参数指定将多少行作为一个命令行参数，根据构建的命令参数个数执行一到多次命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.txt</span></span><br><span class="line">one two </span><br><span class="line">1 2</span><br><span class="line">I II</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt | xargs -t -L 1</span><br><span class="line"><span class="built_in">echo</span> one two</span><br><span class="line">one two</span><br><span class="line"><span class="built_in">echo</span> 1 2</span><br><span class="line">1 2</span><br><span class="line"><span class="built_in">echo</span> I II</span><br><span class="line">I II</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt | xargs -t -L 2</span><br><span class="line"><span class="built_in">echo</span> one two 1 2</span><br><span class="line">one two 1 2</span><br><span class="line"><span class="built_in">echo</span> I II</span><br><span class="line">I II</span><br></pre></td></tr></table></figure><h2 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a>-n 参数</h2><p><code>-n</code> 参数指定将多少项作为一个命令行参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt | xargs -t -n 4</span><br><span class="line"><span class="built_in">echo</span> one two 1 2</span><br><span class="line">one two 1 2</span><br><span class="line"><span class="built_in">echo</span> I II</span><br><span class="line">I II</span><br></pre></td></tr></table></figure><h2 id="I-参数"><a href="#I-参数" class="headerlink" title="-I 参数"></a>-I 参数</h2><p><code>-I</code> 参数为多个命令绑定参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt | xargs -I param sh -c <span class="string">"echo param;touch param"</span></span><br><span class="line">one two</span><br><span class="line">1 2</span><br><span class="line">I II</span><br></pre></td></tr></table></figure><p>命令输除如上结果，并创建对应的 6 个文件</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;xargs - build and execute command lines from standard input&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="//sunxingboo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo yilia 主题点击左侧链接时打开空白页面问题</title>
    <link href="2019/12/17/yilia-issue/"/>
    <id>2019/12/17/yilia-issue/</id>
    <published>2019-12-17T09:30:00.000Z</published>
    <updated>2021-07-09T10:33:40.390Z</updated>
    
    <content type="html"><![CDATA[<p>解决办法：修改 <code>themes/yilia/layout/_partial/post/left-col.ejs</code> 文件中 <code>&lt;nav class=&quot;header-smart-menu&quot;&gt;</code>。</p><a id="more"></a><p>搜索 header-smart-menu</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"header-smart-menu"</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> theme.smart_menu)&#123; %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span>(theme.smart_menu[i])&#123; %&gt;</span><br><span class="line">    &lt;a q-on=<span class="string">"click: openSlider(e, '&lt;%-i%&gt;')"</span> href=<span class="string">"javascript:void(0)"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.smart_menu</span>[<span class="attr">i</span>] %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">            &lt;%&#125;%&gt;</span><br><span class="line">    &lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后 添加 target="_self" 属性</span></span><br><span class="line"><span class="comment">//如果原本是 target="_blank" 则将这个属性去掉</span></span><br><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"header-smart-menu"</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> theme.smart_menu)&#123; %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span>(theme.smart_menu[i])&#123; %&gt;</span><br><span class="line">    &lt;a q-on=<span class="string">"click: openSlider(e, '&lt;%-i%&gt;')"</span> target=<span class="string">"_self"</span> href=<span class="string">"javascript:void(0)"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.smart_menu</span>[<span class="attr">i</span>] %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">            &lt;%&#125;%&gt;</span><br><span class="line">    &lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决办法：修改 &lt;code&gt;themes/yilia/layout/_partial/post/left-col.ejs&lt;/code&gt; 文件中 &lt;code&gt;&amp;lt;nav class=&amp;quot;header-smart-menu&amp;quot;&amp;gt;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="//sunxingboo.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
